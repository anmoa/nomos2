---
title: "Personal Assistants"
description: "Building personal assistant agents with SOFIA for task management, calendar integration, and email processing"
---

# Personal Assistants with SOFIA

SOFIA provides a powerful framework for creating personal assistant agents that can help manage your daily tasks, schedule, communications, and more. This guide will show you how to build effective personal assistants using SOFIA.

## Task Management Assistant

Many of us struggle with organizing and prioritizing tasks. A SOFIA-powered task management assistant can help you stay on top of your to-do list.

### Implementation Example

```yaml
name: TaskMaster
description: A personal task management assistant
steps:
  - id: greeting
    prompt: Greet the user warmly and ask how you can help with their tasks today
    next: listen
    
  - id: listen
    prompt: Listen to the user's request about task management
    routes:
      - when: User wants to add a task
        goto: add_task
      - when: User wants to view tasks
        goto: list_tasks
      - when: User wants to update a task
        goto: update_task
      - when: User wants to mark a task as complete
        goto: complete_task
      - when: User wants task suggestions or prioritization
        goto: suggest_priorities
      - default: general_help
        
  - id: add_task
    prompt: Ask for task details (description, due date, priority)
    tool: task_creator
    next: confirm_add
    
  - id: confirm_add
    prompt: Confirm that the task was added successfully and ask if they'd like to add another task
    routes:
      - when: User wants to add another task
        goto: add_task
      - default: anything_else
        
  - id: list_tasks
    tool: task_retriever
    routes:
      - when: Tasks found
        goto: display_tasks
      - when: No tasks found
        goto: no_tasks
        
  - id: display_tasks
    prompt: Display the tasks in a clear, organized manner with priorities and due dates
    next: task_action
    
  - id: task_action
    prompt: Ask if the user would like to take any action on the displayed tasks
    routes:
      - when: User wants to update a task
        goto: update_task
      - when: User wants to mark a task as complete
        goto: complete_task
      - default: anything_else
        
  - id: update_task
    prompt: Ask which task to update and what changes to make
    tool: task_updater
    next: confirm_update
    
  - id: confirm_update
    prompt: Confirm the task was updated successfully
    next: anything_else
    
  - id: complete_task
    prompt: Ask which task to mark as complete
    tool: task_completer
    next: congratulate
    
  - id: congratulate
    prompt: Congratulate the user on completing the task and provide positive reinforcement
    next: anything_else
    
  - id: no_tasks
    prompt: Inform the user they have no tasks and offer to help create some
    routes:
      - when: User wants to add a task
        goto: add_task
      - default: anything_else
        
  - id: suggest_priorities
    tool: task_analyzer
    prompt: Analyze the user's tasks and suggest priorities based on deadlines and importance
    next: anything_else
    
  - id: general_help
    prompt: Explain what you can do as a task management assistant
    next: listen
    
  - id: anything_else
    prompt: Ask if there's anything else the user needs help with regarding their tasks
    routes:
      - when: User wants more help
        goto: listen
      - default: farewell
        
  - id: farewell
    prompt: Say goodbye in a friendly manner and remind the user you're here to help with their tasks anytime
```

### Task Management Tools

For this assistant, you would implement these tools:

```python
from sofia_agent import Tool
from typing import Dict, List, Optional
import datetime

# A simple in-memory task store for this example
tasks = []

def create_task(description: str, due_date: Optional[str] = None, priority: str = "medium") -> Dict:
    """Create a new task with the given details."""
    task_id = len(tasks) + 1
    task = {
        "id": task_id,
        "description": description,
        "due_date": due_date,
        "priority": priority,
        "created_at": datetime.datetime.now().isoformat(),
        "completed": False
    }
    tasks.append(task)
    return task

def get_tasks(filter_completed: bool = False) -> List[Dict]:
    """Retrieve tasks, optionally filtering out completed ones."""
    if filter_completed:
        return [task for task in tasks if not task["completed"]]
    return tasks

def update_task(task_id: int, description: Optional[str] = None, 
                due_date: Optional[str] = None, priority: Optional[str] = None) -> Dict:
    """Update an existing task."""
    for task in tasks:
        if task["id"] == task_id:
            if description:
                task["description"] = description
            if due_date:
                task["due_date"] = due_date
            if priority:
                task["priority"] = priority
            return task
    raise ValueError(f"Task with ID {task_id} not found")

def complete_task(task_id: int) -> Dict:
    """Mark a task as completed."""
    for task in tasks:
        if task["id"] == task_id:
            task["completed"] = True
            return task
    raise ValueError(f"Task with ID {task_id} not found")

def analyze_tasks() -> Dict:
    """Analyze tasks and provide priority suggestions."""
    open_tasks = [task for task in tasks if not task["completed"]]
    
    # Sort by due date
    has_due_date = [t for t in open_tasks if t["due_date"]]
    no_due_date = [t for t in open_tasks if not t["due_date"]]
    
    # Simple priority logic - in a real app this would be more sophisticated
    has_due_date.sort(key=lambda x: x["due_date"])
    
    urgent = has_due_date[:2]  # Top 2 due soon
    important = [t for t in open_tasks if t["priority"] == "high"]
    
    return {
        "urgent": urgent,
        "important": important,
        "total_open": len(open_tasks),
        "without_deadline": len(no_due_date),
        "suggestions": "Focus on urgent tasks due soon, then high priority items."
    }

# Create SOFIA tools
task_creator_tool = Tool(name="task_creator", function=create_task)
task_retriever_tool = Tool(name="task_retriever", function=get_tasks)
task_updater_tool = Tool(name="task_updater", function=update_task)
task_completer_tool = Tool(name="task_completer", function=complete_task)
task_analyzer_tool = Tool(name="task_analyzer", function=analyze_tasks)
```

## Calendar Assistant

Managing a busy schedule can be challenging. A SOFIA calendar assistant can help users manage appointments, schedule meetings, and avoid conflicts.

### Implementation Example

```yaml
name: Calendar Assistant
description: Manages calendar events, schedules meetings, and sends reminders
steps:
  - id: welcome
    prompt: Greet the user and ask how you can help with their calendar today
    next: listen
    
  - id: listen
    prompt: Listen to the user's calendar-related request
    routes:
      - when: User wants to view schedule
        goto: view_calendar
      - when: User wants to schedule an event
        goto: create_event
      - when: User wants to modify an event
        goto: modify_event
      - when: User wants to find available time
        goto: find_availability
      - default: general_help
        
  - id: view_calendar
    prompt: Ask the user for the time period they want to view
    tool: calendar_viewer
    next: display_events
    
  - id: display_events
    prompt: Display the calendar events in a clear, organized manner
    routes:
      - when: Events found
        goto: event_options
      - when: No events found
        goto: no_events
        
  - id: event_options
    prompt: Ask if the user would like to take any action on the displayed events
    routes:
      - when: User wants to modify an event
        goto: modify_event
      - when: User wants to add a new event
        goto: create_event
      - default: anything_else
        
  - id: create_event
    prompt: Ask for event details (title, time, duration, participants)
    next: check_conflicts
    
  - id: check_conflicts
    tool: conflict_checker
    routes:
      - when: Conflicts found
        goto: handle_conflicts
      - when: No conflicts
        goto: save_event
        
  - id: handle_conflicts
    prompt: Inform the user about the conflicts and suggest alternative times
    routes:
      - when: User accepts alternative
        goto: save_event
      - when: User wants to override
        goto: save_event
      - when: User wants to cancel
        goto: anything_else
        
  - id: save_event
    tool: event_creator
    next: send_invites
    
  - id: send_invites
    prompt: Ask if invites should be sent to participants
    routes:
      - when: User confirms
        goto: process_invites
      - default: confirm_creation
        
  - id: process_invites
    tool: invite_sender
    next: confirm_creation
    
  - id: confirm_creation
    prompt: Confirm that the event was created successfully
    next: anything_else
    
  - id: modify_event
    prompt: Ask which event to modify and what changes to make
    tool: event_modifier
    next: confirm_modification
    
  - id: confirm_modification
    prompt: Confirm the event was modified successfully
    next: update_invitees
    
  - id: update_invitees
    prompt: Ask if participants should be notified of the changes
    routes:
      - when: User confirms
        goto: send_updates
      - default: anything_else
        
  - id: send_updates
    tool: update_sender
    next: anything_else
    
  - id: find_availability
    prompt: Ask for details about the type of availability the user is looking for
    tool: availability_finder
    next: suggest_times
    
  - id: suggest_times
    prompt: Suggest available time slots based on the user's calendar
    routes:
      - when: User selects a time
        goto: create_event
      - default: anything_else
        
  - id: no_events
    prompt: Inform the user they have no events in the specified time period
    next: anything_else
    
  - id: general_help
    prompt: Explain what you can do as a calendar assistant
    next: listen
    
  - id: anything_else
    prompt: Ask if there's anything else the user needs help with regarding their calendar
    routes:
      - when: User wants more help
        goto: listen
      - default: farewell
        
  - id: farewell
    prompt: Say goodbye and remind the user you're here to help manage their calendar anytime
```

## Email Processing Assistant

Email overload is a common problem. A SOFIA email assistant can help categorize, summarize, and prioritize emails, as well as draft responses.

### Implementation Example

```python
from sofia_agent import Sofia, Step, Tool, Route

# Define tools (would connect to email API in a real implementation)
email_fetcher = Tool(name="email_fetcher", function=fetch_emails)
email_summarizer = Tool(name="email_summarizer", function=summarize_email)
email_categorizer = Tool(name="email_categorizer", function=categorize_email)
response_drafter = Tool(name="response_drafter", function=draft_response)
email_sender = Tool(name="email_sender", function=send_email)

# Create email assistant
email_assistant = Sofia(
    name="Email Assistant",
    description="Helps manage emails, draft responses, and prioritize messages",
    steps=[
        Step(
            id="welcome",
            prompt="Greet the user and ask how you can help with their emails today",
            next="listen"
        ),
        Step(
            id="listen",
            prompt="Listen to the user's email-related request",
            routes=[
                Route(when="User wants to check new emails", goto="fetch_new"),
                Route(when="User wants to summarize emails", goto="summarize_inbox"),
                Route(when="User wants to draft a response", goto="get_email_for_response"),
                Route(when="User wants to categorize emails", goto="categorize_inbox"),
                Route(when="User wants to find specific emails", goto="search_emails"),
                Route(default="general_help")
            ]
        ),
        Step(
            id="fetch_new",
            prompt="Fetch recent unread emails",
            tool=email_fetcher,
            routes=[
                Route(when="Emails found", goto="display_emails"),
                Route(when="No new emails", goto="no_emails")
            ]
        ),
        Step(
            id="display_emails",
            prompt="Display email list with sender, subject, and received time",
            next="email_action"
        ),
        Step(
            id="email_action",
            prompt="Ask what action the user would like to take on these emails",
            routes=[
                Route(when="User wants to read an email", goto="read_email"),
                Route(when="User wants to summarize these emails", goto="bulk_summarize"),
                Route(when="User wants to categorize these emails", goto="bulk_categorize"),
                Route(default="anything_else")
            ]
        ),
        Step(
            id="read_email",
            prompt="Ask which email to read and display its contents",
            next="single_email_action"
        ),
        Step(
            id="single_email_action",
            prompt="Ask what action the user would like to take on this email",
            routes=[
                Route(when="User wants to respond", goto="draft_response"),
                Route(when="User wants to summarize", goto="summarize_single"),
                Route(when="User wants to categorize", goto="categorize_single"),
                Route(default="anything_else")
            ]
        ),
        Step(
            id="summarize_inbox",
            prompt="Summarize the user's inbox to provide an overview",
            tool=email_summarizer,
            next="anything_else"
        ),
        Step(
            id="bulk_summarize",
            prompt="Summarize the selected emails",
            tool=email_summarizer,
            next="anything_else"
        ),
        Step(
            id="summarize_single",
            prompt="Provide a concise summary of the email",
            tool=email_summarizer,
            next="anything_else"
        ),
        Step(
            id="get_email_for_response",
            prompt="Ask which email the user wants to respond to",
            next="draft_response"
        ),
        Step(
            id="draft_response",
            prompt="Draft a response to the email based on the user's instructions",
            tool=response_drafter,
            next="review_draft"
        ),
        Step(
            id="review_draft",
            prompt="Ask the user to review the draft and make any needed changes",
            routes=[
                Route(when="User approves draft", goto="send_email"),
                Route(when="User wants changes", goto="edit_draft"),
                Route(when="User wants to discard", goto="anything_else")
            ]
        ),
        Step(
            id="edit_draft",
            prompt="Make the requested changes to the draft",
            next="review_draft"
        ),
        Step(
            id="send_email",
            prompt="Send the email",
            tool=email_sender,
            next="confirm_sent"
        ),
        Step(
            id="confirm_sent",
            prompt="Confirm the email was sent successfully",
            next="anything_else"
        ),
        Step(
            id="categorize_inbox",
            prompt="Categorize emails in the inbox",
            tool=email_categorizer,
            next="anything_else"
        ),
        Step(
            id="bulk_categorize",
            prompt="Categorize the selected emails",
            tool=email_categorizer,
            next="anything_else"
        ),
        Step(
            id="categorize_single",
            prompt="Categorize this email",
            tool=email_categorizer,
            next="anything_else"
        ),
        Step(
            id="search_emails",
            prompt="Ask for search criteria (sender, subject, date range, etc.)",
            tool=email_fetcher,
            routes=[
                Route(when="Emails found", goto="display_emails"),
                Route(when="No emails found", goto="no_emails")
            ]
        ),
        Step(
            id="no_emails",
            prompt="Inform the user that no emails matching their criteria were found",
            next="anything_else"
        ),
        Step(
            id="general_help",
            prompt="Explain what you can do as an email assistant",
            next="listen"
        ),
        Step(
            id="anything_else",
            prompt="Ask if there's anything else the user needs help with regarding their emails",
            routes=[
                Route(when="User wants more help", goto="listen"),
                Route(default="farewell")
            ]
        ),
        Step(
            id="farewell",
            prompt="Say goodbye and remind the user you're here to help manage their emails anytime"
        )
    ]
)
```

## Integration Best Practices

To create effective personal assistants with SOFIA:

1. **Connect to relevant APIs**: Integrate with task management systems, calendar services, and email providers

2. **Use proper authentication**: Implement OAuth or other secure authentication methods for accessing user data

3. **Ensure data privacy**: Store only necessary information and be transparent about data usage

4. **Design for conversation**: Create natural conversational flows that feel helpful rather than robotic

5. **Provide actionable recommendations**: Make suggestions based on patterns and user preferences

6. **Implement contextual memory**: Remember previous interactions to provide more personalized assistance

7. **Support multi-modal interaction**: Allow users to interact via text, voice, or GUI when possible

## User Experience Considerations

When building personal assistants:

- **Respect user time**: Provide concise, actionable information
- **Be proactive**: Offer suggestions based on patterns and upcoming events
- **Provide control**: Always let users override or modify assistant actions
- **Be transparent**: Clearly explain what the assistant can and cannot do
- **Personalize gradually**: Learn user preferences over time rather than asking for everything upfront

## Getting Started

To build your own personal assistant with SOFIA:

1. Identify which personal management tasks would benefit from automation
2. Follow the [installation guide](/docs/getting-started/installation)
3. Review the [tool integration documentation](/docs/concepts/tools-integration)
4. Adapt the examples from this page to your specific needs

<Callout type="info">
  Personal assistants work best when they can integrate with the tools and services you already use. Consider which APIs and services your assistant will need to connect with before starting development.
</Callout>
