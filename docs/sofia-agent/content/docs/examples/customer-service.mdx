---
title: Customer Service Agent
description: Example of building a customer service agent with SOFIA
---

# Customer Service Agent Example

This example demonstrates how to build a comprehensive customer service agent with SOFIA. The agent can handle customer inquiries, troubleshoot common issues, escalate to human agents when necessary, and maintain a consistent support experience.

## Use Case Overview

Customer service agents need to handle a variety of tasks:

- Answering common questions about products and services
- Troubleshooting technical issues
- Processing returns and refunds
- Escalating complex issues to human agents
- Collecting customer feedback

Our SOFIA-based agent will handle all these tasks with a well-defined conversation flow and integration with relevant tools.

## Prerequisites

Ensure you have:

1. SOFIA installed (`pip install sofia-agent`)
2. Access to an LLM provider (OpenAI, Anthropic, etc.)
3. Basic understanding of Python and SOFIA concepts

## Agent Architecture

Our customer service agent uses a multi-step flow:

1. **Greeting** - Welcome the customer and identify their needs
2. **Classification** - Categorize the issue type
3. **Information Gathering** - Collect necessary details
4. **Resolution** - Attempt to resolve the issue
5. **Escalation** - Hand off to a human agent if needed
6. **Feedback** - Collect customer satisfaction data

## Implementation

### 1. Define the Agent Flow

```python
from sofia_agent.models.flow import Flow, Nodes, Step

# Define the customer service flow
flow = Flow(
    name="customer_service_agent",
    entry_point="greeting",
    nodes=Nodes(
        greeting=Step(
            name="Greeting",
            system_prompt=(
                "You are a helpful customer service agent for Acme Inc., "
                "a company that sells electronics. Greet the customer warmly "
                "and ask how you can help them today."
            ),
            transitions={
                "identify_issue": "Always transition to identify_issue after greeting."
            },
        ),
        identify_issue=Step(
            name="Identify Issue",
            system_prompt=(
                "Identify the customer's issue and categorize it as one of: "
                "- product_question: General product information\n"
                "- technical_support: Help with product functionality\n"
                "- return_refund: Process returns or refunds\n"
                "- other: Any other inquiries\n\n"
                "Ask clarifying questions if needed."
            ),
            transitions={
                "product_info": "If issue is related to product information.",
                "tech_support": "If issue is related to technical support.",
                "returns": "If issue is about returns or refunds.",
                "general_inquiry": "For all other inquiries."
            },
        ),
        product_info=Step(
            name="Product Information",
            system_prompt=(
                "Provide detailed information about Acme products. "
                "Use the product_catalog tool to look up specifications. "
                "Be informative and highlight key features."
            ),
            transitions={
                "resolution": "After providing product information.",
                "tech_support": "If customer has technical questions about the product.",
            },
        ),
        tech_support=Step(
            name="Technical Support",
            system_prompt=(
                "Help troubleshoot technical issues with Acme products. "
                "Use the troubleshooting_guide tool to find solutions. "
                "Follow a step-by-step approach to diagnose problems."
            ),
            transitions={
                "resolution": "If issue is resolved.",
                "escalate": "If unable to resolve the technical issue."
            },
        ),
        returns=Step(
            name="Returns and Refunds",
            system_prompt=(
                "Process return or refund requests. Verify eligibility using "
                "the return_policy tool. Collect order number and reason for return."
            ),
            transitions={
                "resolution": "After successfully processing return/refund.",
                "escalate": "If return/refund request requires manager approval."
            },
        ),
        general_inquiry=Step(
            name="General Inquiry",
            system_prompt=(
                "Handle general inquiries about Acme Inc. Provide information "
                "about store locations, hours, company policies, etc."
            ),
            transitions={
                "resolution": "After answering general inquiry."
            },
        ),
        escalate=Step(
            name="Escalation",
            system_prompt=(
                "Explain to the customer that their issue requires assistance "
                "from a specialist. Collect their contact information and "
                "let them know a representative will contact them within 24 hours."
            ),
            transitions={
                "feedback": "After escalation process is complete."
            },
        ),
        resolution=Step(
            name="Resolution",
            system_prompt=(
                "Confirm that the customer's issue has been resolved. "
                "Summarize what was done and ask if there's anything else "
                "they need help with."
            ),
            transitions={
                "identify_issue": "If customer has another issue.",
                "feedback": "If customer has no more issues."
            },
        ),
        feedback=Step(
            name="Feedback",
            system_prompt=(
                "Thank the customer for their time and ask them to rate their "
                "experience from 1-5 stars. Record their feedback using the "
                "save_feedback tool."
            ),
            transitions={},  # End of flow
        ),
    ),
)
```

### 2. Create the Custom Tools

```python
from typing import Dict, Any, List
from sofia_agent.tools.base import Tool
import json

class ProductCatalogTool(Tool):
    """Tool for querying product catalog information."""
    
    def __init__(self):
        """Initialize with a sample product catalog."""
        # In production, this would connect to a database or API
        self.catalog = {
            "laptop-pro": {
                "name": "Acme LaptopPro X1",
                "price": 1299.99,
                "category": "Computers",
                "specs": {
                    "processor": "Intel i7 12th Gen",
                    "ram": "16GB DDR5",
                    "storage": "512GB SSD",
                    "display": "15.6 inch 4K",
                    "battery": "12 hours"
                },
                "warranty": "2 years standard"
            },
            "smartphone-max": {
                "name": "Acme SmartPhone Max",
                "price": 899.99,
                "category": "Phones",
                "specs": {
                    "processor": "Snapdragon 8 Gen 2",
                    "ram": "8GB",
                    "storage": "256GB",
                    "display": "6.7 inch OLED",
                    "battery": "5000mAh"
                },
                "warranty": "1 year standard"
            },
            # Additional products would be listed here
        }
    
    def search_product(self, query: str) -> Dict[str, Any]:
        """
        Search for products matching the query.
        
        Args:
            query: Search term to match against products
            
        Returns:
            Matching product information
        """
        query = query.lower()
        results = []
        
        for product_id, details in self.catalog.items():
            if (query in product_id.lower() or 
                query in details["name"].lower() or 
                query in details["category"].lower()):
                results.append(details)
        
        return {"results": results, "count": len(results)}
    
    def get_product_by_id(self, product_id: str) -> Dict[str, Any]:
        """
        Get a specific product by ID.
        
        Args:
            product_id: The product identifier
            
        Returns:
            Product details or error message
        """
        if product_id in self.catalog:
            return self.catalog[product_id]
        return {"error": "Product not found"}

class TroubleshootingGuideTool(Tool):
    """Tool for accessing troubleshooting procedures."""
    
    def __init__(self):
        # In production, this would connect to a knowledge base
        self.guides = {
            "laptop-wont-turn-on": [
                "Ensure the laptop is charged or connected to power",
                "Press and hold the power button for 10 seconds",
                "Disconnect all peripherals and try again",
                "If it has a removable battery, remove it, wait 30 seconds, reinsert and try again"
            ],
            "blue-screen-error": [
                "Note the error code displayed",
                "Restart the computer and see if the error persists",
                "If it boots, check for Windows updates",
                "Run a system file check using sfc /scannow in Command Prompt"
            ],
            # Additional guides would be listed here
        }
    
    def search_guides(self, query: str) -> Dict[str, Any]:
        """
        Search for troubleshooting guides related to the query.
        
        Args:
            query: Issue description to find relevant guides
            
        Returns:
            List of matching guides
        """
        query = query.lower()
        matches = {}
        
        for issue, steps in self.guides.items():
            if query in issue.lower():
                matches[issue] = steps
        
        return {"matches": matches, "count": len(matches)}
    
    def get_guide(self, issue_id: str) -> Dict[str, Any]:
        """
        Get specific troubleshooting guide by ID.
        
        Args:
            issue_id: Identifier for the troubleshooting guide
            
        Returns:
            Step-by-step guide or error message
        """
        if issue_id in self.guides:
            return {"issue": issue_id, "steps": self.guides[issue_id]}
        return {"error": "Guide not found"}

class ReturnPolicyTool(Tool):
    """Tool for checking return eligibility and processing returns."""
    
    def __init__(self):
        # Sample policies and order data
        self.policies = {
            "standard": {
                "days": 30,
                "condition": "unopened",
                "restocking_fee": 0
            },
            "opened_electronics": {
                "days": 14,
                "condition": "opened",
                "restocking_fee": 0.15  # 15%
            },
            "clearance": {
                "days": 7,
                "condition": "any",
                "restocking_fee": 0.25  # 25%
            }
        }
        
        # Mock order database
        self.orders = {
            "ORD-12345": {
                "customer": "customer123",
                "date": "2023-04-15",
                "items": [
                    {"product_id": "laptop-pro", "price": 1299.99, "policy": "standard"}
                ],
                "status": "delivered"
            },
            # Additional orders would be listed here
        }
    
    def check_eligibility(self, order_id: str) -> Dict[str, Any]:
        """
        Check if an order is eligible for return.
        
        Args:
            order_id: The order identifier
            
        Returns:
            Eligibility information
        """
        if order_id not in self.orders:
            return {"eligible": False, "reason": "Order not found"}
        
        order = self.orders[order_id]
        # In a real implementation, we would check dates and other factors
        
        return {
            "eligible": True,
            "order": order,
            "return_deadline": "2023-05-15",  # Example date
            "instructions": "Item must be in original packaging"
        }
    
    def process_return(self, order_id: str, reason: str) -> Dict[str, Any]:
        """
        Process a return request.
        
        Args:
            order_id: The order identifier
            reason: Reason for return
            
        Returns:
            Return confirmation details
        """
        if order_id not in self.orders:
            return {"success": False, "error": "Order not found"}
        
        # In a real implementation, this would update databases
        return {
            "success": True,
            "return_id": f"RET-{order_id}-A",
            "refund_amount": 1299.99,  # Example amount
            "instructions": "Please print the return label and ship within 7 days"
        }

class FeedbackTool(Tool):
    """Tool for collecting and saving customer feedback."""
    
    def __init__(self):
        self.feedback_store = []
    
    def save_feedback(self, rating: int, comments: str = "", customer_id: str = "anonymous") -> Dict[str, Any]:
        """
        Save customer feedback.
        
        Args:
            rating: Numeric rating (1-5)
            comments: Optional feedback comments
            customer_id: Optional customer identifier
            
        Returns:
            Confirmation of feedback saved
        """
        if not 1 <= rating <= 5:
            return {"success": False, "error": "Rating must be between 1 and 5"}
        
        feedback = {
            "customer_id": customer_id,
            "rating": rating,
            "comments": comments,
            "timestamp": "2023-05-01T14:30:00Z"  # Example timestamp
        }
        
        self.feedback_store.append(feedback)
        return {"success": True, "feedback_id": len(self.feedback_store)}
```

### 3. Initialize the Agent

```python
from sofia_agent import Agent
from sofia_agent.llm import OpenAILLM
from typing import Dict, Any

# Initialize LLM
llm = OpenAILLM(
    model="gpt-4",
    api_key="your-openai-api-key"
)

# Initialize tools
product_catalog = ProductCatalogTool()
troubleshooting = TroubleshootingGuideTool()
return_policy = ReturnPolicyTool()
feedback = FeedbackTool()

# Create the agent with the defined flow and tools
customer_service_agent = Agent(
    flow=flow,
    llm=llm,
    tools={
        "product_catalog": product_catalog,
        "troubleshooting_guide": troubleshooting,
        "return_policy": return_policy,
        "save_feedback": feedback
    }
)

# Create a session
session = customer_service_agent.create_session()
```

### 4. Run the Conversation

```python
# Get the initial greeting
decision, _ = session.next(None)
print(f"Agent: {decision.input}")

# User asks about a product
user_message = "I'm interested in your laptop models. What do you recommend?"
decision, _ = session.next(user_message)
print(f"User: {user_message}")
print(f"Agent: {decision.input}")

# User asks about specifications
user_message = "What are the specs of the LaptopPro X1?"
decision, _ = session.next(user_message)
print(f"User: {user_message}")
print(f"Agent: {decision.input}")

# User has a technical issue
user_message = "Actually, I already have one but it won't turn on anymore."
decision, _ = session.next(user_message)
print(f"User: {user_message}")
print(f"Agent: {decision.input}")

# Agent provides troubleshooting steps
# ...continue with more interactions
```

## Web Service Integration

To deploy this as a web service, integrate with SOFIA's API server:

```python
from fastapi import FastAPI
from sofia_agent.server import create_agent_router

app = FastAPI()

# Register the agent with the API router
agent_router = create_agent_router(customer_service_agent)
app.include_router(agent_router, prefix="/customer-service")

# Start with: uvicorn app:app --host 0.0.0.0 --port 8000
```

## Advanced Features

### Conversation Memory

To implement memory for returning customers:

```python
from sofia_agent.memory import RedisMemory

# Initialize memory backend
memory = RedisMemory(
    redis_url="redis://localhost:6379/0",
    ttl=86400 * 30  # 30 days
)

# Create agent with memory
customer_service_agent = Agent(
    flow=flow,
    llm=llm,
    tools={...},
    memory=memory
)
```

### Handoff to Human Agents

Implement seamless handoff to human agents:

```python
class HumanHandoffTool(Tool):
    """Tool for escalating to human agents."""
    
    def __init__(self, ticketing_system_url: str, api_key: str):
        self.url = ticketing_system_url
        self.api_key = api_key
    
    def create_ticket(self, 
                      customer_id: str, 
                      issue_summary: str, 
                      conversation_history: List[Dict[str, Any]], 
                      priority: str = "medium") -> Dict[str, Any]:
        """
        Create a support ticket for human follow-up.
        
        Args:
            customer_id: Customer identifier
            issue_summary: Brief description of the issue
            conversation_history: Prior conversation with the bot
            priority: Ticket priority level
            
        Returns:
            Ticket details
        """
        # In production, this would call your ticketing API
        return {
            "ticket_id": "T-12345",
            "estimated_response": "within 24 hours",
            "priority": priority,
            "status": "assigned"
        }
```

### Analytics Integration

Implement analytics for continuous improvement:

```python
class AnalyticsTool(Tool):
    """Tool for tracking conversation analytics."""
    
    def __init__(self, analytics_api_url: str, api_key: str):
        self.url = analytics_api_url
        self.api_key = api_key
    
    def track_interaction(self, 
                         session_id: str, 
                         issue_type: str, 
                         resolution_status: str, 
                         duration_seconds: int) -> Dict[str, Any]:
        """
        Track a customer service interaction.
        
        Args:
            session_id: The conversation session ID
            issue_type: Category of the customer issue
            resolution_status: Whether and how the issue was resolved
            duration_seconds: Length of the conversation
            
        Returns:
            Confirmation of tracking
        """
        # In production, this would send data to your analytics system
        return {"success": True, "tracked_at": "2023-05-01T14:35:00Z"}
```

## Performance Metrics

Evaluate the agent using these key metrics:

1. **Resolution Rate** - Percentage of issues resolved without human intervention
2. **Customer Satisfaction** - Average feedback rating
3. **Average Handling Time** - Duration of typical customer interactions
4. **Escalation Rate** - Percentage of interactions requiring human assistance
5. **Topic Distribution** - Breakdown of customer inquiries by type

## Conclusion

This example demonstrates how to build a comprehensive customer service agent using SOFIA. By defining a clear conversation flow and integrating relevant tools, the agent can handle a wide range of customer inquiries efficiently and escalate complex issues when necessary.

The modular design allows for easy extension with additional capabilities such as:

- Integration with CRM systems for personalized service
- Multilingual support for global customers
- Proactive issue identification and resolution
- A/B testing of different conversation flows

By leveraging SOFIA's powerful orchestration capabilities, businesses can create customer service agents that provide consistent, high-quality support while reducing operational costs.
