---
title: Tools Integration
description: Understanding how tools work in SOFIA and how to create custom tools
---

# Tools Integration

Tools are the mechanism that allow a SOFIA agent to interact with the outside world, fetch information, process data, and take actions. This page explains how tools work in SOFIA and how to create and integrate your own custom tools.

## What Are Tools?

Tools in SOFIA are functions that:

- Can be called by the agent during a conversation
- Have documented parameters and return values
- Are registered with the agent at initialization
- Can perform any action a Python function can perform

<Mermaid
  chart="
graph TD
    A[Sofia Agent] --> B[Tool Registry]
    B --> C[Custom Tools]
    B --> D[Package Tools]
    C --> E[Python Functions]
    D --> F[Standard Library]
    D --> G[External Packages]
    E --> H[Tool Execution]
    F --> H
    G --> H
    H --> I[Tool Result]
    I --> A"
/>

## Types of Tools

SOFIA supports two primary ways to integrate tools:

### 1. Custom Python Functions

Custom tools are Python functions that you create and register with your SOFIA agent:

```python
def get_weather(location: str) -> str:
    """Get the current weather for a location.

    Args:
        location: The city and state or country

    Returns:
        A string describing the current weather
    """
    # Implementation code here
    return f"The weather in {location} is sunny with a high of 75Â°F"

# Register with SOFIA
sofia = Sofia(
    name="weather_agent",
    tools=[get_weather],
    # Other configuration...
)
```

### 2. Package-based Tools

Package tools reference existing functions from Python packages using string notation:

```python
sofia = Sofia(
    name="math_agent",
    tools=["math:sqrt", "random:randint"],
    # Other configuration...
)
```

This allows the agent to use the `sqrt` function from the `math` module and the `randint` function from the `random` module.

## Tool Structure

A well-defined tool has:

1. **Clear Function Signature**: Parameter names and types
2. **Docstring**: Description of what the tool does
3. **Return Type**: What the tool returns

SOFIA will use type annotations and docstrings to generate documentation for the LLM about how to use the tool.

## Creating Custom Tools

When creating custom tools, follow these best practices:

<Callout type="info">
  Type annotations are important for SOFIA to understand your tools' interfaces
  and generate proper documentation.
</Callout>

### Basic Tool Example

```python
def search_database(query: str, limit: int = 10) -> list:
    """Search the database for records matching the query.

    Args:
        query: The search query string
        limit: Maximum number of results to return (default: 10)

    Returns:
        A list of matching database records
    """
    # Actual implementation would connect to a database
    results = [{"id": 1, "name": "Example"}, {"id": 2, "name": "Test"}]
    return results[:limit]
```

### Tool with Error Handling

Tools should handle errors gracefully and return informative error messages:

```python
def divide_numbers(a: float, b: float) -> float:
    """Divide the first number by the second.

    Args:
        a: The dividend
        b: The divisor

    Returns:
        The result of a divided by b

    Raises:
        ValueError: If b is zero
    """
    if b == 0:
        raise ValueError("Cannot divide by zero")
    return a / b
```

## Tool Error Handling

When a tool raises an exception, SOFIA will:

1. Catch the exception
2. Format an error message
3. Present the error to the LLM
4. Allow the LLM to decide on recovery action

<Tabs>
  <Tab label="Tool Raising Error">
    ```python
    def get_user(user_id: str) -> dict:
        """Get user information by ID.
        
        Args:
            user_id: The user's unique ID
            
        Returns:
            User information as a dictionary
        """
        if not user_id.isdigit():
            raise ValueError(f"Invalid user ID format: {user_id}")
        
        # Rest of implementation
    ```
  </Tab>
  <Tab label="SOFIA Handling Error">
    ```python
    # Internal SOFIA processing
    try:
        result = tool_function(**args)
        return {
            "status": "success",
            "data": result
        }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "error_type": type(e).__name__
        }
    ```
  </Tab>
  <Tab label="LLM Response">
    ```
    I encountered an error when trying to get user information: 
    Invalid user ID format: abc123
    
    Please provide a numeric user ID instead.
    ```
  </Tab>
</Tabs>

## Advanced Tool Integration

### Tool with Complex Types

Tools can use more complex types, including:

- Custom classes
- Nested dictionaries
- Lists of objects

SOFIA will properly document these for the LLM:

```python
from typing import List, Dict, Any

def batch_process(items: List[Dict[str, Any]], operation: str) -> List[Dict[str, Any]]:
    """Process a batch of items with the specified operation.

    Args:
        items: List of items to process, each as a dictionary
        operation: Operation to perform on each item

    Returns:
        List of processed items
    """
    # Implementation
    return items  # Processed items
```

### Stateful Tools

Tools can maintain state between calls by using class methods:

```python
class Calculator:
    def __init__(self):
        self.memory = 0

    def add(self, value: float) -> float:
        """Add a value to the calculator's memory.

        Args:
            value: Number to add

        Returns:
            New memory value
        """
        self.memory += value
        return self.memory

    def clear(self) -> float:
        """Reset the calculator's memory to zero.

        Returns:
            New memory value (0)
        """
        self.memory = 0
        return self.memory

# Register methods as tools
calculator = Calculator()
sofia = Sofia(
    name="calculator_agent",
    tools=[calculator.add, calculator.clear],
    # Other configuration...
)
```

## Package Tool Integration

### Standard Library

SOFIA can use most standard library functions:

```python
sofia = Sofia(
    name="utility_agent",
    tools=[
        "json:dumps",
        "json:loads",
        "re:search",
        "random:choice",
        "datetime:datetime.now"
    ],
    # Other configuration...
)
```

### Third-Party Packages

External packages can also be integrated:

```python
# Make sure the packages are installed
sofia = Sofia(
    name="data_agent",
    tools=[
        "pandas:read_csv",
        "numpy:mean",
        "requests:get"
    ],
    # Other configuration...
)
```

## Best Practices

When creating and using tools:

1. **Keep tools focused**: Each tool should do one thing well
2. **Provide clear documentation**: Good docstrings help the LLM use tools effectively
3. **Handle errors gracefully**: Return informative error messages
4. **Use appropriate types**: Type annotations help SOFIA understand your tools
5. **Test tools independently**: Verify tools work correctly before integrating them

<Callout type="warning">
  Avoid creating tools with side effects that can't be undone, especially for
  destructive operations.
</Callout>

## Next Steps

- Learn about [Session Management](/concepts/session-management) to understand how tool results are incorporated into the conversation
- Explore [LLM Integration](/concepts/llm-integration) to understand how the LLM decides when to use tools
- Learn how to [extend SOFIA](/guides/extending-sofia) with custom tools and components
