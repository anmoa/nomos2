---
title: Tool Development
description: Comprehensive guide to developing and using tools in SOFIA
---

# Tool Development

Tools are the primary way for SOFIA agents to interact with external systems, access data, and perform actions. This guide covers tool development in depth, including creating custom tools, integrating with packages, handling errors, and best practices.

## Tool Architecture

SOFIA's tool architecture is designed for flexibility and simplicity:

<div className="flex justify-center my-8">
```mermaid
classDiagram
    class Tool {
        +name: str
        +description: str
        +execute(*args, **kwargs)
        +get_parameter_schema()
    }
    
    class FunctionTool {
        +function: Callable
        +name: str
        +description: str
        +execute(*args, **kwargs)
        +get_parameter_schema()
    }
    
    class PackageTool {
        +module: str
        +function: str
        +name: str
        +description: str
        +execute(*args, **kwargs)
        +get_parameter_schema()
    }
    
    class CustomTool {
        +name: str
        +description: str
        +execute(*args, **kwargs)
        +get_parameter_schema()
    }
    
    Tool <|-- FunctionTool
    Tool <|-- PackageTool
    Tool <|-- CustomTool
```
</div>

## Tool Types

SOFIA supports different ways to define tools:

### 1. Function-based Tools

The simplest way to create tools is by defining Python functions:

```python
def get_weather(location: str, units: str = "metric") -> str:
    """Get the current weather for a location.
    
    Args:
        location: The city and state/country
        units: Units system, either "metric" or "imperial"
        
    Returns:
        A string with the current weather
    """
    # Implementation code
    if units == "metric":
        temp = "22°C"
    else:
        temp = "72°F"
    
    return f"The weather in {location} is sunny with a high of {temp}"

# Register with SOFIA
from sofia import Sofia

sofia = Sofia(
    name="weather_agent",
    tools=[get_weather],
    # Other configuration...
)
```

### 2. Class Method Tools

For tools that need to maintain state:

```python
class Calculator:
    def __init__(self):
        self.memory = 0
    
    def add(self, value: float) -> float:
        """Add a value to the calculator's memory.
        
        Args:
            value: Number to add
            
        Returns:
            New memory value
        """
        self.memory += value
        return self.memory
    
    def clear(self) -> float:
        """Reset the calculator's memory to zero.
        
        Returns:
            New memory value (0)
        """
        self.memory = 0
        return self.memory

# Create calculator instance
calculator = Calculator()

# Register methods as tools
sofia = Sofia(
    name="calculator_agent",
    tools=[calculator.add, calculator.clear],
    # Other configuration...
)
```

### 3. Package-based Tools

Reference existing functions from Python packages:

```python
sofia = Sofia(
    name="utility_agent",
    tools=[
        "json:dumps",            # json.dumps function
        "json:loads",            # json.loads function
        "random:choice",         # random.choice function
        "math:sqrt",             # math.sqrt function
        "datetime:datetime.now"  # datetime.datetime.now function
    ],
    # Other configuration...
)
```

### 4. Custom Tool Classes

Implement the `Tool` interface for maximum control:

```python
from sofia.models.tool import Tool
from typing import Dict, Any, Optional

class DatabaseSearchTool(Tool):
    def __init__(self, db_connection_string: str):
        """Create a new database search tool.
        
        Args:
            db_connection_string: Connection string for the database
        """
        self.name = "search_database"
        self.description = "Search the database for records matching the query"
        self.db = self._connect_to_db(db_connection_string)
    
    def _connect_to_db(self, connection_string: str):
        # Connect to database
        # This is a placeholder
        return {"connected": True}
    
    def execute(self, query: str, limit: int = 10) -> Dict[str, Any]:
        """Search the database for records matching the query.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return
            
        Returns:
            A dictionary with search results
        """
        # Execute database query
        # This is a placeholder
        results = [
            {"id": 1, "name": "Product A", "price": 19.99},
            {"id": 2, "name": "Product B", "price": 29.99}
        ]
        
        return {
            "results": results[:limit],
            "count": len(results),
            "query": query
        }
    
    def get_parameter_schema(self) -> Dict[str, Dict[str, Any]]:
        """Get the parameter schema for this tool."""
        return {
            "query": {
                "type": "string",
                "description": "The search query string"
            },
            "limit": {
                "type": "integer",
                "description": "Maximum number of results to return",
                "default": 10
            }
        }

# Create and register the tool
db_tool = DatabaseSearchTool("postgresql://user:pass@localhost/db")

sofia = Sofia(
    name="database_agent",
    tools=[db_tool],
    # Other configuration...
)
```

## Tool Documentation

Clear documentation is critical for tools to be used effectively by the LLM:

### Type Annotations

Type annotations help SOFIA understand tool parameters and return values:

```python
from typing import List, Dict, Any, Optional, Union

def search_products(
    query: str,
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None,
    sort_by: str = "relevance",
    limit: int = 10
) -> List[Dict[str, Any]]:
    """Search for products matching the criteria.
    
    Args:
        query: Search query string
        category: Optional product category filter
        min_price: Minimum price filter
        max_price: Maximum price filter
        sort_by: Sort order, one of "relevance", "price_asc", "price_desc", "newest"
        limit: Maximum number of results to return
        
    Returns:
        List of matching products
    """
    # Implementation
    return []
```

### Docstrings

Comprehensive docstrings detail:
- What the tool does
- Parameter descriptions
- Return value description
- Examples (optional)
- Potential errors (optional)

```python
def format_date(date_string: str, output_format: str = "YYYY-MM-DD") -> str:
    """Format a date string to the specified format.
    
    This tool takes a date string in various formats and converts it to
    the specified output format.
    
    Args:
        date_string: The input date string (e.g., "January 1, 2023", "01/01/2023")
        output_format: The desired output format. Supported format codes:
            - YYYY: 4-digit year
            - MM: 2-digit month (01-12)
            - DD: 2-digit day (01-31)
            - MMMM: Full month name
            - MMM: 3-letter month abbreviation
            
    Returns:
        The formatted date string
        
    Example:
        format_date("January 1, 2023", "MM/DD/YYYY") -> "01/01/2023"
        format_date("2023-01-01", "MMMM DD, YYYY") -> "January 01, 2023"
        
    Raises:
        ValueError: If the date_string cannot be parsed or the output_format is invalid
    """
    # Implementation
    return "2023-01-01"  # Placeholder
```

## Parameter Schema

SOFIA automatically generates a parameter schema from type annotations and docstrings, but you can also provide it explicitly:

```python
def get_parameter_schema() -> Dict[str, Dict[str, Any]]:
    """Get the parameter schema for this tool."""
    return {
        "query": {
            "type": "string",
            "description": "The search query string",
            "required": True
        },
        "limit": {
            "type": "integer",
            "description": "Maximum number of results to return",
            "default": 10,
            "minimum": 1,
            "maximum": 100
        },
        "category": {
            "type": "string",
            "description": "Product category filter",
            "enum": ["electronics", "clothing", "home", "books"],
            "required": False
        }
    }
```

### JSON Schema Types

SOFIA uses JSON Schema for parameter validation:

| Python Type | JSON Schema Type | Example |
|-------------|------------------|---------|
| `str` | `"string"` | `{"type": "string"}` |
| `int` | `"integer"` | `{"type": "integer"}` |
| `float` | `"number"` | `{"type": "number"}` |
| `bool` | `"boolean"` | `{"type": "boolean"}` |
| `List[T]` | `"array"` | `{"type": "array", "items": {"type": "string"}}` |
| `Dict[str, T]` | `"object"` | `{"type": "object"}` |
| `Union[T, U]` | `"anyOf"` | `{"anyOf": [{"type": "string"}, {"type": "integer"}]}` |
| `Optional[T]` | `type` + `"required": false` | `{"type": "string", "required": false}` |
| `Literal` | `"enum"` | `{"type": "string", "enum": ["option1", "option2"]}` |

## Error Handling

Proper error handling is essential for robust tools:

```python
def divide_numbers(a: float, b: float) -> Dict[str, Any]:
    """Divide the first number by the second.
    
    Args:
        a: The dividend
        b: The divisor
        
    Returns:
        A dictionary with the result or error message
        
    Raises:
        ValueError: If b is zero
    """
    try:
        if b == 0:
            raise ValueError("Cannot divide by zero")
        
        result = a / b
        return {
            "success": True,
            "result": result
        }
    except Exception as e:
        return {
            "success": False,
            "error": str(e),
            "error_type": type(e).__name__
        }
```

### Error Handling Best Practices

1. **Be specific about errors**: Return detailed error messages
2. **Return structured errors**: Include error type, message, and context
3. **Graceful degradation**: Return partial results if possible
4. **Log errors**: Log details for debugging

## Asynchronous Tools

For non-blocking operations, use async tools:

```python
import asyncio
import aiohttp
from typing import Dict, Any

async def fetch_api_data(url: str, timeout: int = 10) -> Dict[str, Any]:
    """Fetch data from an API endpoint asynchronously.
    
    Args:
        url: The API endpoint URL
        timeout: Request timeout in seconds
        
    Returns:
        API response data
    """
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url, timeout=timeout) as response:
                if response.status != 200:
                    return {
                        "success": False,
                        "status_code": response.status,
                        "error": f"API returned status code {response.status}"
                    }
                
                data = await response.json()
                return {
                    "success": True,
                    "data": data
                }
        except aiohttp.ClientError as e:
            return {
                "success": False,
                "error": str(e),
                "error_type": "ClientError"
            }
        except asyncio.TimeoutError:
            return {
                "success": False,
                "error": f"Request timed out after {timeout} seconds",
                "error_type": "TimeoutError"
            }

# Register the async tool
sofia = Sofia(
    name="api_agent",
    tools=[fetch_api_data],
    # Other configuration...
)
```

SOFIA automatically handles async tool execution:
- For synchronous workflows, it will await the result
- For asynchronous workflows, it will integrate with the async flow

## Tool Modules

Group related tools in modules for better organization:

```python
# File: crm_tools.py
def get_customer(customer_id: str) -> dict:
    """Get customer information by ID.
    
    Args:
        customer_id: The customer's unique ID
        
    Returns:
        Customer information as a dictionary
    """
    # Implementation
    return {"id": customer_id, "name": "John Doe", "email": "john@example.com"}

def update_customer(customer_id: str, data: dict) -> dict:
    """Update customer information.
    
    Args:
        customer_id: The customer's unique ID
        data: Dictionary with fields to update
        
    Returns:
        Updated customer information
    """
    # Implementation
    return {"id": customer_id, "name": data.get("name", "John Doe"), "updated": True}

def list_orders(customer_id: str, limit: int = 5) -> list:
    """List orders for a customer.
    
    Args:
        customer_id: The customer's unique ID
        limit: Maximum number of orders to return
        
    Returns:
        List of orders
    """
    # Implementation
    orders = [
        {"id": "order1", "amount": 99.99, "date": "2023-01-15"},
        {"id": "order2", "amount": 49.99, "date": "2023-02-20"}
    ]
    return orders[:limit]
```

Register the module:

```python
sofia = Sofia(
    name="crm_agent",
    custom_tool_modules=["path.to.crm_tools"],
    # Other configuration...
)
```

## Tool Registration

There are multiple ways to register tools with SOFIA:

### Direct Registration

```python
from sofia import Sofia

# Create a SOFIA agent with tools
sofia = Sofia(
    name="tool_agent",
    tools=[
        get_weather,
        calculator.add,
        "json:dumps",
        db_search_tool
    ],
    # Other configuration...
)
```

### Post-Initialization Registration

```python
from sofia import Sofia

# Create a SOFIA agent
sofia = Sofia(
    name="tool_agent",
    # Other configuration...
)

# Register tools after initialization
sofia.register_tool(get_weather)
sofia.register_tools([calculator.add, calculator.clear])
sofia.register_tool("json:dumps")
sofia.register_tool(db_search_tool)
```

### Conditional Registration

```python
from sofia import Sofia

# Create a SOFIA agent
sofia = Sofia(
    name="dynamic_tool_agent",
    # Other configuration...
)

# Register tools conditionally
if enable_weather_feature:
    sofia.register_tool(get_weather)

if database_available:
    db_tool = DatabaseSearchTool(db_connection_string)
    sofia.register_tool(db_tool)
```

## Tool Dependencies

Manage tool dependencies cleanly:

```python
from sofia import Sofia
from typing import Dict, Any

# Create shared dependencies
class SharedResources:
    def __init__(self, api_key: str, base_url: str):
        self.api_key = api_key
        self.base_url = base_url
        self.client = self._create_client()
    
    def _create_client(self):
        # Initialize API client
        return {"initialized": True, "api_key": self.api_key}

# Create a resources instance
resources = SharedResources(
    api_key="your-api-key",
    base_url="https://api.example.com"
)

# Create tools that share resources
def get_user_profile(resources: SharedResources, user_id: str) -> Dict[str, Any]:
    """Get a user's profile information.
    
    Args:
        resources: Shared API resources
        user_id: User's unique ID
        
    Returns:
        User profile information
    """
    # Use the shared client
    # This is a placeholder
    return {"id": user_id, "name": "John Doe", "email": "john@example.com"}

def update_user_profile(resources: SharedResources, user_id: str, data: Dict[str, Any]) -> Dict[str, Any]:
    """Update a user's profile information.
    
    Args:
        resources: Shared API resources
        user_id: User's unique ID
        data: Profile data to update
        
    Returns:
        Updated user profile
    """
    # Use the shared client
    # This is a placeholder
    return {"id": user_id, "updated": True, **data}

# Create partial functions with the resources injected
from functools import partial
get_user = partial(get_user_profile, resources)
update_user = partial(update_user_profile, resources)

# Update function metadata for documentation
get_user.__name__ = "get_user"
get_user.__doc__ = get_user_profile.__doc__.replace("resources: SharedResources, ", "")
update_user.__name__ = "update_user"
update_user.__doc__ = update_user_profile.__doc__.replace("resources: SharedResources, ", "")

# Register tools
sofia = Sofia(
    name="user_profile_agent",
    tools=[get_user, update_user],
    # Other configuration...
)
```

## Complex Return Types

Tools can return complex data structures:

```python
from typing import List, Dict, Any
from dataclasses import dataclass
import json

@dataclass
class Product:
    id: str
    name: str
    price: float
    category: str
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "name": self.name,
            "price": self.price,
            "category": self.category
        }

def search_products(query: str, limit: int = 5) -> List[Product]:
    """Search for products matching the query.
    
    Args:
        query: Search query
        limit: Maximum number of results
        
    Returns:
        List of matching products
    """
    # This is a placeholder implementation
    products = [
        Product(id="p1", name="Laptop", price=999.99, category="electronics"),
        Product(id="p2", name="Headphones", price=89.99, category="electronics"),
        Product(id="p3", name="T-shirt", price=19.99, category="clothing")
    ]
    
    # Filter products by query
    results = [p for p in products if query.lower() in p.name.lower()]
    
    return results[:limit]

# SOFIA will automatically convert the Product objects to dictionaries
# using the to_dict method if available, or by using vars() or dict()
```

## Tool Authorization and Security

Implement authorization for sensitive tools:

```python
from sofia import Sofia
from sofia.models.tool import Tool
from typing import Dict, Any, Optional
import functools

def require_permission(permission: str):
    """Decorator to require a specific permission for a tool."""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(session_id: str, *args, **kwargs):
            # Get the session
            session = sofia.get_session(session_id)
            if not session:
                return {
                    "error": "Session not found",
                    "authorized": False
                }
            
            # Check if the user has the required permission
            user_permissions = session.get_variable("permissions", [])
            if permission not in user_permissions:
                return {
                    "error": f"Permission denied: {permission} required",
                    "authorized": False
                }
            
            # Execute the function if authorized
            return func(*args, **kwargs)
        
        # Store the required permission
        wrapper.required_permission = permission
        return wrapper
    return decorator

@require_permission("admin")
def delete_user(user_id: str) -> Dict[str, Any]:
    """Delete a user account.
    
    Args:
        user_id: User's unique ID
        
    Returns:
        Status of the deletion operation
    """
    # Implementation
    return {"success": True, "deleted_user_id": user_id}

# Register the tool
sofia = Sofia(
    name="admin_agent",
    tools=[delete_user],
    # Other configuration...
)
```

## Tool Validation

SOFIA validates tools at registration time:

```python
from sofia import Sofia
from sofia.validation import validate_tool

# Validate a tool before registration
validation_result = validate_tool(get_weather)
if validation_result["valid"]:
    print("Tool is valid")
else:
    print(f"Tool validation failed: {validation_result['errors']}")

# Sofia also validates tools when registering them
try:
    sofia = Sofia(
        name="validated_agent",
        tools=[get_weather],
        # Other configuration...
    )
except ValueError as e:
    print(f"Tool validation error: {e}")
```

## Tool Versioning

Handle tool versioning for backward compatibility:

```python
def get_weather_v1(location: str) -> str:
    """Get the current weather for a location (v1).
    
    Args:
        location: The city and state/country
        
    Returns:
        A string with the current weather
    """
    return f"The weather in {location} is sunny."

def get_weather_v2(location: str, units: str = "metric") -> Dict[str, Any]:
    """Get the current weather for a location (v2).
    
    Args:
        location: The city and state/country
        units: Units system, either "metric" or "imperial"
        
    Returns:
        Weather information including temperature, conditions, and forecast
    """
    if units == "metric":
        temp = "22°C"
    else:
        temp = "72°F"
    
    return {
        "location": location,
        "temperature": temp,
        "conditions": "sunny",
        "forecast": ["sunny", "partly cloudy", "rainy"]
    }

# Register both versions
sofia = Sofia(
    name="weather_agent",
    tools=[
        get_weather_v1,  # Legacy version
        get_weather_v2   # New version
    ],
    # Other configuration...
)
```

## Tool Composition

Create complex tools by composing simpler ones:

```python
from typing import Dict, Any, List

def fetch_news(topic: str, limit: int = 5) -> List[Dict[str, Any]]:
    """Fetch news articles about a topic.
    
    Args:
        topic: News topic
        limit: Maximum number of articles
        
    Returns:
        List of news articles
    """
    # Implementation
    return [
        {"title": f"News about {topic} 1", "source": "CNN", "summary": "..."},
        {"title": f"News about {topic} 2", "source": "BBC", "summary": "..."}
    ][:limit]

def summarize_text(text: str, max_length: int = 100) -> str:
    """Summarize a text to the specified maximum length.
    
    Args:
        text: Text to summarize
        max_length: Maximum length of the summary
        
    Returns:
        Summarized text
    """
    # Implementation
    if len(text) <= max_length:
        return text
    return text[:max_length - 3] + "..."

def news_summary(topic: str, limit: int = 3, summary_length: int = 50) -> List[Dict[str, Any]]:
    """Fetch and summarize news about a topic.
    
    Args:
        topic: News topic
        limit: Maximum number of articles
        summary_length: Maximum length of each summary
        
    Returns:
        List of summarized news articles
    """
    # Fetch news
    articles = fetch_news(topic, limit)
    
    # Summarize each article
    for article in articles:
        article["summary"] = summarize_text(article["summary"], summary_length)
    
    return articles

# Register the composite tool
sofia = Sofia(
    name="news_agent",
    tools=[news_summary],
    # Other configuration...
)
```

## Testing Tools

Write tests for your tools:

```python
import pytest
from unittest.mock import patch, MagicMock

# Tool to test
def get_exchange_rate(from_currency: str, to_currency: str) -> float:
    """Get the exchange rate from one currency to another.
    
    Args:
        from_currency: Source currency code (e.g., "USD")
        to_currency: Target currency code (e.g., "EUR")
        
    Returns:
        Exchange rate as a float
    """
    # Implementation that calls an API
    import requests
    response = requests.get(
        f"https://api.example.com/exchange-rate",
        params={"from": from_currency, "to": to_currency}
    )
    data = response.json()
    return data["rate"]

# Test the tool
def test_get_exchange_rate():
    # Mock the requests.get function
    with patch("requests.get") as mock_get:
        # Set up the mock response
        mock_response = MagicMock()
        mock_response.json.return_value = {"rate": 0.85}
        mock_get.return_value = mock_response
        
        # Call the function
        rate = get_exchange_rate("USD", "EUR")
        
        # Verify the function called the API correctly
        mock_get.assert_called_once_with(
            "https://api.example.com/exchange-rate",
            params={"from": "USD", "to": "EUR"}
        )
        
        # Verify the result
        assert rate == 0.85
```

## Tool Performance Optimization

Optimize tools for better performance:

```python
import time
import functools
from typing import Dict, Any, Callable, TypeVar, cast

T = TypeVar('T')

def memoize(func: Callable[..., T]) -> Callable[..., T]:
    """Memoize a function to cache its results."""
    cache: Dict[str, Any] = {}
    
    @functools.wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> T:
        # Create a cache key from the arguments
        key = str(args) + str(sorted(kwargs.items()))
        
        # Return cached result if available
        if key in cache:
            return cast(T, cache[key])
        
        # Call the function and cache the result
        result = func(*args, **kwargs)
        cache[key] = result
        return result
    
    return wrapper

@memoize
def expensive_calculation(a: int, b: int) -> int:
    """Perform an expensive calculation.
    
    Args:
        a: First number
        b: Second number
        
    Returns:
        Calculation result
    """
    # Simulate an expensive operation
    time.sleep(1)
    return a * b

# Register the optimized tool
sofia = Sofia(
    name="calculation_agent",
    tools=[expensive_calculation],
    # Other configuration...
)
```

## Tool Monitoring

Implement monitoring for tool usage:

```python
import time
import functools
import logging
from typing import Dict, Any, Callable, TypeVar

T = TypeVar('T')

def monitor_tool(func: Callable[..., T]) -> Callable[..., T]:
    """Decorator to monitor tool execution."""
    @functools.wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> T:
        # Record start time
        start_time = time.time()
        
        try:
            # Execute the function
            result = func(*args, **kwargs)
            success = True
        except Exception as e:
            # Log the error
            logging.error(f"Tool {func.__name__} failed: {str(e)}")
            success = False
            raise
        finally:
            # Record end time
            end_time = time.time()
            duration = end_time - start_time
            
            # Log execution metrics
            logging.info(
                f"Tool {func.__name__} executed in {duration:.4f}s "
                f"(success: {success})"
            )
            
            # Here you could also send metrics to a monitoring system
            # such as Prometheus, StatsD, etc.
        
        return result
    
    return wrapper

@monitor_tool
def fetch_data(url: str) -> Dict[str, Any]:
    """Fetch data from a URL.
    
    Args:
        url: URL to fetch data from
        
    Returns:
        Fetched data
    """
    # Implementation
    import requests
    response = requests.get(url)
    return response.json()

# Register the monitored tool
sofia = Sofia(
    name="monitored_agent",
    tools=[fetch_data],
    # Other configuration...
)
```

## Tool Best Practices

1. **Follow Single Responsibility Principle**: Each tool should do one thing well
2. **Use Clear Names**: Tool names should be descriptive and follow a consistent naming convention
3. **Document Thoroughly**: Provide comprehensive docstrings
4. **Handle Errors Gracefully**: Implement proper error handling
5. **Return Structured Data**: Use dictionaries with clear keys
6. **Validate Inputs**: Check inputs before processing
7. **Test Extensively**: Write tests for all tools
8. **Optimize Performance**: Implement caching and other optimizations where appropriate
9. **Monitor Usage**: Track tool performance and errors
10. **Keep Tools Focused**: Avoid creating overly complex or general-purpose tools

<Callout type="info">
  Remember that the LLM will select and use tools based on their names and documentation. Clear, specific documentation helps the LLM choose the right tool for each task.
</Callout>

## Next Steps

- Learn about [Server API](/api/server-api) to integrate tools with SOFIA's HTTP API
- Explore [Core API](/api/core-api) for detailed information about SOFIA's core APIs
- Visit [LLM Providers](/api/llm-providers) to understand how LLMs interact with tools
