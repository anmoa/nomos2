---
title: Core API
description: Comprehensive documentation for SOFIA's core API classes and methods
---

# Core API Reference

This page provides comprehensive documentation for SOFIA's core API, including the main `Sofia` class, `Step` and `Route` classes, session management, and configuration options.

## Sofia Class

The `Sofia` class is the main entry point for creating and managing agents.

### Constructor

```python
class Sofia:
    def __init__(
        self,
        name: str,
        description: Optional[str] = None,
        steps: Optional[List[Step]] = None,
        tools: Optional[List[Union[str, Callable, Tool]]] = None,
        custom_tool_modules: Optional[List[str]] = None,
        llm_provider: str = "openai",
        llm_config: Optional[Dict[str, Any]] = None,
        session_store: Optional[SessionStoreBase] = None,
        session_config: Optional[Dict[str, Any]] = None,
        system_message: Optional[str] = None,
        persona: Optional[str] = None,
        prompt_templates: Optional[Dict[str, str]] = None,
        middleware: Optional[List[Middleware]] = None,
        plugins: Optional[List[SofiaPlugin]] = None,
        enable_logging: bool = True,
        log_level: str = "INFO",
        enable_tracing: bool = False,
        metrics: Optional[MetricsProvider] = None,
        event_stream: Optional[EventStream] = None
    )
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `name` | `str` | The name of the agent | Required |
| `description` | `Optional[str]` | A description of the agent's purpose | `None` |
| `steps` | `Optional[List[Step]]` | A list of steps that define the agent's flow | `None` |
| `tools` | `Optional[List[Union[str, Callable, Tool]]]` | Tools available to the agent | `None` |
| `custom_tool_modules` | `Optional[List[str]]` | Python modules containing custom tools | `None` |
| `llm_provider` | `str` | The LLM provider to use | `"openai"` |
| `llm_config` | `Optional[Dict[str, Any]]` | Configuration for the LLM provider | `None` |
| `session_store` | `Optional[SessionStoreBase]` | Session storage implementation | `None` |
| `session_config` | `Optional[Dict[str, Any]]` | Configuration for sessions | `None` |
| `system_message` | `Optional[str]` | System message for the LLM | `None` |
| `persona` | `Optional[str]` | Persona description for the agent | `None` |
| `prompt_templates` | `Optional[Dict[str, str]]` | Custom prompt templates | `None` |
| `middleware` | `Optional[List[Middleware]]` | Request processing middleware | `None` |
| `plugins` | `Optional[List[SofiaPlugin]]` | Plugins to extend functionality | `None` |
| `enable_logging` | `bool` | Whether to enable logging | `True` |
| `log_level` | `str` | Logging level | `"INFO"` |
| `enable_tracing` | `bool` | Whether to enable distributed tracing | `False` |
| `metrics` | `Optional[MetricsProvider]` | Metrics provider implementation | `None` |
| `event_stream` | `Optional[EventStream]` | Event streaming implementation | `None` |

### Alternative Constructors

#### From YAML

```python
@classmethod
def from_yaml(cls, yaml_path: str, **overrides) -> 'Sofia':
    """Create a Sofia agent from a YAML configuration file.
    
    Args:
        yaml_path: Path to the YAML configuration file
        **overrides: Optional overrides for the configuration
        
    Returns:
        A new Sofia agent
    """
```

#### From Dictionary

```python
@classmethod
def from_dict(cls, config: Dict[str, Any], **overrides) -> 'Sofia':
    """Create a Sofia agent from a dictionary configuration.
    
    Args:
        config: Dictionary configuration
        **overrides: Optional overrides for the configuration
        
    Returns:
        A new Sofia agent
    """
```

### Session Management Methods

#### Creating and Managing Sessions

```python
def new_session(self, session_id: Optional[str] = None, metadata: Optional[Dict[str, Any]] = None) -> FlowSession:
    """Create a new session.
    
    Args:
        session_id: Optional custom session ID
        metadata: Optional session metadata
        
    Returns:
        A new FlowSession
    """

def get_session(self, session_id: str) -> Optional[FlowSession]:
    """Get an existing session by ID.
    
    Args:
        session_id: Session ID
        
    Returns:
        The session if found, None otherwise
    """

def delete_session(self, session_id: str) -> bool:
    """Delete a session.
    
    Args:
        session_id: Session ID
        
    Returns:
        True if the session was deleted, False otherwise
    """

def get_active_sessions(self) -> List[FlowSession]:
    """Get all active sessions.
    
    Returns:
        List of active sessions
    """

def cleanup_sessions(self, max_age: Optional[int] = None) -> int:
    """Clean up expired sessions.
    
    Args:
        max_age: Maximum session age in seconds
        
    Returns:
        Number of sessions cleaned up
    """
```

#### Session Operations

```python
def fork_session(self, session_id: str, new_session_id: Optional[str] = None) -> Optional[FlowSession]:
    """Create a fork of an existing session.
    
    Args:
        session_id: ID of the session to fork
        new_session_id: Optional ID for the new session
        
    Returns:
        The new forked session if successful, None otherwise
    """

def merge_sessions(self, source_session_id: str, target_session_id: str) -> bool:
    """Merge a source session into a target session.
    
    Args:
        source_session_id: Source session ID
        target_session_id: Target session ID
        
    Returns:
        True if successful, False otherwise
    """

def create_snapshot(self, session_id: str) -> Optional[Dict[str, Any]]:
    """Create a snapshot of a session.
    
    Args:
        session_id: Session ID
        
    Returns:
        Session snapshot if successful, None otherwise
    """

def restore_session_from_snapshot(self, snapshot: Dict[str, Any]) -> Optional[FlowSession]:
    """Restore a session from a snapshot.
    
    Args:
        snapshot: Session snapshot
        
    Returns:
        Restored session if successful, None otherwise
    """
```

### Event Handling

```python
def on(self, event_name: str, handler: Callable[[Dict[str, Any]], None]) -> None:
    """Register an event handler.
    
    Args:
        event_name: Name of the event
        handler: Event handler function
    """

def emit(self, event_name: str, event_data: Dict[str, Any]) -> None:
    """Emit an event.
    
    Args:
        event_name: Name of the event
        event_data: Event data
    """
```

### Tool Management

```python
def register_tool(self, tool: Union[str, Callable, Tool]) -> None:
    """Register a tool with the agent.
    
    Args:
        tool: Tool to register
    """

def register_tools(self, tools: List[Union[str, Callable, Tool]]) -> None:
    """Register multiple tools with the agent.
    
    Args:
        tools: Tools to register
    """

def get_tool(self, tool_name: str) -> Optional[Tool]:
    """Get a tool by name.
    
    Args:
        tool_name: Name of the tool
        
    Returns:
        The tool if found, None otherwise
    """

def list_tools(self) -> List[str]:
    """List all available tools.
    
    Returns:
        List of tool names
    """
```

### Agent Configuration

```python
def add_step(self, step: Step) -> None:
    """Add a step to the agent.
    
    Args:
        step: Step to add
    """

def remove_step(self, step_id: str) -> bool:
    """Remove a step from the agent.
    
    Args:
        step_id: ID of the step to remove
        
    Returns:
        True if the step was removed, False otherwise
    """

def get_step(self, step_id: str) -> Optional[Step]:
    """Get a step by ID.
    
    Args:
        step_id: Step ID
        
    Returns:
        The step if found, None otherwise
    """

def update_llm_config(self, config: Dict[str, Any]) -> None:
    """Update the LLM configuration.
    
    Args:
        config: New LLM configuration
    """

def set_system_message(self, message: str) -> None:
    """Set the system message.
    
    Args:
        message: System message
    """

def set_persona(self, persona: str) -> None:
    """Set the agent persona.
    
    Args:
        persona: Persona description
    """
```

### Validation and Utilities

```python
def validate(self) -> bool:
    """Validate the agent configuration.
    
    Returns:
        True if the configuration is valid, False otherwise
    """

@staticmethod
def validate_yaml(yaml_path: str) -> bool:
    """Validate a YAML configuration file.
    
    Args:
        yaml_path: Path to the YAML configuration file
        
    Returns:
        True if the configuration is valid, False otherwise
    """

def to_dict(self) -> Dict[str, Any]:
    """Convert the agent to a dictionary.
    
    Returns:
        Dictionary representation of the agent
    """

def to_yaml(self, yaml_path: str) -> None:
    """Save the agent configuration to a YAML file.
    
    Args:
        yaml_path: Path to save the YAML file
    """
```

## Step Class

The `Step` class defines a discrete state in the agent's flow.

### Constructor

```python
class Step:
    def __init__(
        self,
        step_id: str,
        description: str,
        available_tools: Optional[List[str]] = None,
        routes: Optional[List[Route]] = None
    )
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `step_id` | `str` | Unique identifier for the step | Required |
| `description` | `str` | Description of the step's purpose | Required |
| `available_tools` | `Optional[List[str]]` | Tools available in this step | `None` |
| `routes` | `Optional[List[Route]]` | Routes to other steps | `None` |

### Methods

```python
def add_route(self, route: Route) -> None:
    """Add a route to the step.
    
    Args:
        route: Route to add
    """

def remove_route(self, target: str) -> bool:
    """Remove a route to the specified target.
    
    Args:
        target: Target step ID
        
    Returns:
        True if the route was removed, False otherwise
    """

def add_tool(self, tool_name: str) -> None:
    """Add a tool to the step.
    
    Args:
        tool_name: Name of the tool to add
    """

def remove_tool(self, tool_name: str) -> bool:
    """Remove a tool from the step.
    
    Args:
        tool_name: Name of the tool to remove
        
    Returns:
        True if the tool was removed, False otherwise
    """

def to_dict(self) -> Dict[str, Any]:
    """Convert the step to a dictionary.
    
    Returns:
        Dictionary representation of the step
    """
```

## Route Class

The `Route` class defines a transition between steps.

### Constructor

```python
class Route:
    def __init__(
        self,
        target: str,
        condition: str
    )
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `target` | `str` | ID of the target step | Required |
| `condition` | `str` | Condition for taking this route | Required |

### Methods

```python
def to_dict(self) -> Dict[str, Any]:
    """Convert the route to a dictionary.
    
    Returns:
        Dictionary representation of the route
    """
```

## FlowSession Class

The `FlowSession` class manages the state of a conversation.

### Constructor

```python
class FlowSession:
    def __init__(
        self,
        sofia: Sofia,
        session_id: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    )
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `sofia` | `Sofia` | The Sofia agent | Required |
| `session_id` | `Optional[str]` | Unique session identifier | `None` |
| `metadata` | `Optional[Dict[str, Any]]` | Session metadata | `None` |

### Properties

```python
@property
def session_id(self) -> str:
    """Get the session ID."""

@property
def current_step(self) -> str:
    """Get the current step ID."""

@property
def history(self) -> List[Dict[str, Any]]:
    """Get the conversation history."""

@property
def variables(self) -> Dict[str, Any]:
    """Get the session variables."""

@property
def metadata(self) -> Dict[str, Any]:
    """Get the session metadata."""

@property
def created_at(self) -> datetime:
    """Get the session creation time."""

@property
def updated_at(self) -> datetime:
    """Get the last update time."""
```

### Message Methods

```python
def send_message(self, message: str) -> FlowResponse:
    """Send a user message to the agent.
    
    Args:
        message: User message
        
    Returns:
        Agent response
    """

async def send_message_async(self, message: str) -> FlowResponse:
    """Send a user message to the agent asynchronously.
    
    Args:
        message: User message
        
    Returns:
        Agent response
    """

def add_message(self, role: str, content: str) -> None:
    """Add a message to the conversation history.
    
    Args:
        role: Message role (user, assistant, system, tool)
        content: Message content
    """
```

### State Management

```python
def set_variable(self, key: str, value: Any) -> None:
    """Set a session variable.
    
    Args:
        key: Variable name
        value: Variable value
    """

def get_variable(self, key: str, default: Any = None) -> Any:
    """Get a session variable.
    
    Args:
        key: Variable name
        default: Default value if not found
        
    Returns:
        Variable value or default
    """

def delete_variable(self, key: str) -> bool:
    """Delete a session variable.
    
    Args:
        key: Variable name
        
    Returns:
        True if the variable was deleted, False otherwise
    """

def set_step(self, step_id: str) -> bool:
    """Set the current step.
    
    Args:
        step_id: Step ID
        
    Returns:
        True if successful, False otherwise
    """

def clear_history(self, keep_system_message: bool = True) -> None:
    """Clear the conversation history.
    
    Args:
        keep_system_message: Whether to keep the system message
    """

def create_snapshot(self) -> Dict[str, Any]:
    """Create a snapshot of the session state.
    
    Returns:
        Session snapshot
    """

def restore_from_snapshot(self, snapshot: Dict[str, Any]) -> bool:
    """Restore session state from a snapshot.
    
    Args:
        snapshot: Session snapshot
        
    Returns:
        True if successful, False otherwise
    """
```

## FlowResponse Class

The `FlowResponse` class represents an agent's response to a user message.

### Constructor

```python
class FlowResponse:
    def __init__(
        self,
        message: str,
        step: str,
        tool_calls: Optional[List[Dict[str, Any]]] = None,
        tool_results: Optional[List[Dict[str, Any]]] = None,
        route_taken: Optional[str] = None,
        decision_info: Optional[Dict[str, Any]] = None
    )
```

#### Parameters

| Parameter | Type | Description | Default |
|-----------|------|-------------|---------|
| `message` | `str` | Agent's response message | Required |
| `step` | `str` | Current step ID | Required |
| `tool_calls` | `Optional[List[Dict[str, Any]]]` | List of tool calls | `None` |
| `tool_results` | `Optional[List[Dict[str, Any]]]` | List of tool results | `None` |
| `route_taken` | `Optional[str]` | Route taken (if any) | `None` |
| `decision_info` | `Optional[Dict[str, Any]]` | Information about the decision | `None` |

### Properties

```python
@property
def message(self) -> str:
    """Get the response message."""

@property
def step(self) -> str:
    """Get the current step ID."""

@property
def tool_calls(self) -> List[Dict[str, Any]]:
    """Get the tool calls."""

@property
def tool_results(self) -> List[Dict[str, Any]]:
    """Get the tool results."""

@property
def route_taken(self) -> Optional[str]:
    """Get the route taken, if any."""

@property
def decision_info(self) -> Dict[str, Any]:
    """Get information about the decision process."""
```

### Methods

```python
def to_dict(self) -> Dict[str, Any]:
    """Convert the response to a dictionary.
    
    Returns:
        Dictionary representation of the response
    """
```

## SessionStoreBase Class

The `SessionStoreBase` class is the base class for session storage implementations.

### Interface

```python
class SessionStoreBase(ABC):
    @abstractmethod
    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """Save session data.
        
        Args:
            session_id: Session ID
            session_data: Session data
            
        Returns:
            True if successful, False otherwise
        """
    
    @abstractmethod
    def load_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Load session data.
        
        Args:
            session_id: Session ID
            
        Returns:
            Session data if found, None otherwise
        """
    
    @abstractmethod
    def delete_session(self, session_id: str) -> bool:
        """Delete a session.
        
        Args:
            session_id: Session ID
            
        Returns:
            True if successful, False otherwise
        """
    
    @abstractmethod
    def list_sessions(self) -> List[str]:
        """List all session IDs.
        
        Returns:
            List of session IDs
        """
```

## Configuration Types

### LLM Configuration

Common LLM configuration options:

```python
llm_config = {
    "model": "gpt-4",  # LLM model name
    "api_key": "your-api-key",  # API key
    "temperature": 0.7,  # Response randomness (0.0 to 1.0)
    "max_tokens": 1000,  # Maximum tokens in response
    "retry_count": 3,  # Number of retry attempts
    "request_timeout": 30,  # Request timeout in seconds
    "fallback_providers": [  # Fallback providers
        {
            "provider": "mistral",
            "config": {
                "model": "mistral-large-latest",
                "api_key": "your-mistral-api-key"
            }
        }
    ]
}
```

### Session Configuration

Common session configuration options:

```python
session_config = {
    "max_history_messages": 50,  # Maximum messages in history
    "summarize_threshold": 30,  # Threshold for summarization
    "summarize_history": True,  # Whether to summarize history
    "session_timeout": 3600,  # Session timeout in seconds
    "session_refresh_on_activity": True,  # Reset timeout on activity
    "inactive_session_check_interval": 900  # Check interval in seconds
}
```

### Prompt Templates

Available prompt template keys:

```python
prompt_templates = {
    "system": "You are {name}, an AI assistant that helps with {description}. {system_message}",
    "user": "{message}",
    "assistant": "{message}",
    "tool_call": "Use the {tool_name} tool with these parameters: {tool_params}",
    "tool_result": "The tool returned the following result: {result}",
    "route_selection": "Based on the conversation, choose the most appropriate next step."
}
```

## Usage Examples

### Basic Usage

```python
from sofia import Sofia
from sofia.models.flow import Step, Route

# Create steps
greeting_step = Step(
    step_id="greeting",
    description="Initial greeting and problem identification",
    routes=[
        Route(target="help", condition="User needs assistance")
    ]
)

help_step = Step(
    step_id="help",
    description="Provide help and information",
    available_tools=["search_docs", "get_faq"],
    routes=[
        Route(target="greeting", condition="User's question is answered")
    ]
)

# Create Sofia agent
sofia = Sofia(
    name="help_desk",
    description="A help desk assistant",
    steps=[greeting_step, help_step],
    llm_provider="openai",
    llm_config={
        "model": "gpt-4",
        "api_key": "your-openai-api-key"
    },
    system_message="You are a helpful assistant that answers questions about our products."
)

# Create a session
session = sofia.new_session()

# Send a message
response = session.send_message("I need help with my account")
print(response.message)
```

### Advanced Usage with Event Handling

```python
from sofia import Sofia
from sofia.models.flow import Step, Route
from sofia.session import RedisSessionStore

# Create a session store
session_store = RedisSessionStore(redis_url="redis://localhost:6379/0")

# Create a Sofia agent
sofia = Sofia(
    name="customer_service",
    description="A customer service assistant",
    # Configuration...
    session_store=session_store
)

# Register event handlers
@sofia.on("session_created")
def handle_session_created(event):
    session_id = event.get("session_id")
    print(f"New session created: {session_id}")
    # Initialize session resources

@sofia.on("message_received")
def handle_message(event):
    session_id = event.get("session_id")
    message = event.get("message")
    print(f"Message received in session {session_id}: {message}")
    # Log message, update analytics

@sofia.on("tool_called")
def handle_tool_call(event):
    session_id = event.get("session_id")
    tool_name = event.get("tool_name")
    params = event.get("params")
    print(f"Tool {tool_name} called in session {session_id} with params {params}")
    # Log tool usage, monitor performance

@sofia.on("step_changed")
def handle_step_change(event):
    session_id = event.get("session_id")
    from_step = event.get("from_step")
    to_step = event.get("to_step")
    print(f"Session {session_id} moved from {from_step} to {to_step}")
    # Track flow progress, update metrics

# Usage
session = sofia.new_session()
response = session.send_message("Hello")
```

## Next Steps

- Learn about [LLM Providers](/api/llm-providers) to understand LLM integration
- Explore [Tool Development](/api/tool-development) to create custom tools
- Visit [Server API](/api/server-api) to learn about SOFIA's HTTP API
