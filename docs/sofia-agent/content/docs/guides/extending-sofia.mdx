---
title: Extending SOFIA
description: Learn how to extend SOFIA with custom tools, LLM integrations, and plugins
---

# Extending SOFIA

SOFIA is designed with extensibility in mind. This guide covers how to extend SOFIA with custom components, including tools, LLM integrations, session stores, and more. You'll learn how to build on SOFIA's architecture to create specialized agents for your specific needs.

## Extension Points

SOFIA provides several key extension points:

<div className="flex justify-center my-8">
```mermaid
flowchart TB
    SOFIA[Sofia Core] --> Tools[Custom Tools]
    SOFIA --> LLMs[LLM Providers]
    SOFIA --> Steps[Custom Steps]
    SOFIA --> Sessions[Session Stores]
    SOFIA --> Events[Event Handlers]
    SOFIA --> Middleware[Middleware]
    SOFIA --> Metrics[Metrics Providers]
```
</div>

## Creating Custom Tools

Tools are the primary way to extend SOFIA's capabilities:

### Simple Function Tools

The simplest way to create a tool is with a Python function:

```python
def get_weather(location: str, units: str = "metric") -> str:
    """Get the current weather for a location.
    
    Args:
        location: The city and state or country
        units: The units to use, either "metric" or "imperial"
        
    Returns:
        A string describing the current weather
    """
    # Implementation code
    if units == "metric":
        temp = "22°C"
    else:
        temp = "72°F"
    
    return f"The weather in {location} is sunny with a high of {temp}"

# Register with SOFIA
from sofia import Sofia

sofia = Sofia(
    name="weather_agent",
    tools=[get_weather],
    # Other configuration...
)
```

### Class-based Tools

For more complex tools with state, use classes:

```python
class Calculator:
    def __init__(self):
        self.memory = 0
    
    def add(self, value: float) -> float:
        """Add a value to the calculator's memory.
        
        Args:
            value: Number to add
            
        Returns:
            New memory value
        """
        self.memory += value
        return self.memory
    
    def subtract(self, value: float) -> float:
        """Subtract a value from the calculator's memory.
        
        Args:
            value: Number to subtract
            
        Returns:
            New memory value
        """
        self.memory -= value
        return self.memory
    
    def multiply(self, value: float) -> float:
        """Multiply the calculator's memory by a value.
        
        Args:
            value: Number to multiply by
            
        Returns:
            New memory value
        """
        self.memory *= value
        return self.memory
    
    def clear(self) -> float:
        """Reset the calculator's memory to zero.
        
        Returns:
            New memory value (0)
        """
        self.memory = 0
        return self.memory

# Create calculator instance
calculator = Calculator()

# Register methods as tools
sofia = Sofia(
    name="calculator_agent",
    tools=[
        calculator.add,
        calculator.subtract,
        calculator.multiply,
        calculator.clear
    ],
    # Other configuration...
)
```

### Tool Classes

For the most control, implement the `Tool` interface:

```python
from sofia.models.tool import Tool
from typing import Dict, Any, Optional

class DatabaseSearchTool(Tool):
    def __init__(self, db_connection_string: str):
        """Create a new database search tool.
        
        Args:
            db_connection_string: Connection string for the database
        """
        self.name = "search_database"
        self.description = "Search the database for records matching the query"
        self.db = self._connect_to_db(db_connection_string)
    
    def _connect_to_db(self, connection_string: str):
        # Connect to database
        # This is a placeholder
        return {"connected": True}
    
    def execute(self, query: str, limit: int = 10) -> Dict[str, Any]:
        """Search the database for records matching the query.
        
        Args:
            query: The search query string
            limit: Maximum number of results to return
            
        Returns:
            A dictionary with search results
        """
        # Execute database query
        # This is a placeholder
        results = [
            {"id": 1, "name": "Product A", "price": 19.99},
            {"id": 2, "name": "Product B", "price": 29.99}
        ]
        
        return {
            "results": results[:limit],
            "count": len(results),
            "query": query
        }
    
    def get_parameter_schema(self) -> Dict[str, Dict[str, Any]]:
        """Get the parameter schema for this tool."""
        return {
            "query": {
                "type": "string",
                "description": "The search query string"
            },
            "limit": {
                "type": "integer",
                "description": "Maximum number of results to return",
                "default": 10
            }
        }

# Create and register the tool
db_tool = DatabaseSearchTool("postgresql://user:pass@localhost/db")

sofia = Sofia(
    name="database_agent",
    tools=[db_tool],
    # Other configuration...
)
```

### Tool Modules

You can organize related tools in modules:

```python
# File: crm_tools.py
def get_customer(customer_id: str) -> dict:
    """Get customer information by ID.
    
    Args:
        customer_id: The customer's unique ID
        
    Returns:
        Customer information as a dictionary
    """
    # Implementation
    return {"id": customer_id, "name": "John Doe", "email": "john@example.com"}

def update_customer(customer_id: str, data: dict) -> dict:
    """Update customer information.
    
    Args:
        customer_id: The customer's unique ID
        data: Dictionary with fields to update
        
    Returns:
        Updated customer information
    """
    # Implementation
    return {"id": customer_id, "name": data.get("name", "John Doe"), "updated": True}

def list_orders(customer_id: str, limit: int = 5) -> list:
    """List orders for a customer.
    
    Args:
        customer_id: The customer's unique ID
        limit: Maximum number of orders to return
        
    Returns:
        List of orders
    """
    # Implementation
    orders = [
        {"id": "order1", "amount": 99.99, "date": "2023-01-15"},
        {"id": "order2", "amount": 49.99, "date": "2023-02-20"}
    ]
    return orders[:limit]
```

Register the module:

```python
sofia = Sofia(
    name="crm_agent",
    custom_tool_modules=["path.to.crm_tools"],
    # Other configuration...
)
```

Or import and register specific tools:

```python
from path.to.crm_tools import get_customer, update_customer

sofia = Sofia(
    name="customer_agent",
    tools=[get_customer, update_customer],
    # Other configuration...
)
```

### Async Tools

For non-blocking operations, use async tools:

```python
import asyncio
import aiohttp

async def fetch_api_data(url: str, timeout: int = 10) -> dict:
    """Fetch data from an API endpoint.
    
    Args:
        url: The API endpoint URL
        timeout: Request timeout in seconds
        
    Returns:
        API response data
    """
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url, timeout=timeout) as response:
                response.raise_for_status()
                return await response.json()
        except aiohttp.ClientError as e:
            return {"error": str(e)}

# Register the async tool
sofia = Sofia(
    name="api_agent",
    tools=[fetch_api_data],
    # Other configuration...
)
```

SOFIA will automatically handle async tool execution.

## Creating Custom LLM Providers

Extend SOFIA to work with your preferred LLM:

```python
from sofia.llms.base import LLMBase
from typing import Dict, Any, List, Optional

class CustomLLM(LLMBase):
    def __init__(self, config: Dict[str, Any]):
        super().__init__(config)
        # Initialize your LLM client
        self.api_key = config.get("api_key")
        self.model = config.get("model", "default-model")
        self.client = YourLLMClient(self.api_key)  # Replace with actual client
    
    def _get_output(
        self,
        name: str,
        steps: List[Dict[str, Any]],
        current_step: str,
        tools: List[Dict[str, Any]],
        history: List[Dict[str, Any]],
        response_format: Dict[str, Any],
        system_message: Optional[str] = None,
        persona: Optional[str] = None
    ) -> Dict[str, Any]:
        """Get the next decision from the LLM.
        
        Args:
            name: Agent name
            steps: List of step definitions
            current_step: ID of the current step
            tools: List of available tools
            history: Conversation history
            response_format: Expected response format
            system_message: Optional system message
            persona: Optional persona description
            
        Returns:
            LLM response according to response_format
        """
        # Format the prompt for your LLM
        prompt = self._format_prompt(
            name=name,
            steps=steps,
            current_step=current_step,
            tools=tools,
            history=history,
            system_message=system_message,
            persona=persona
        )
        
        # Call your LLM
        response = self.client.generate(
            model=self.model,
            prompt=prompt,
            max_tokens=self.config.get("max_tokens", 1000),
            temperature=self.config.get("temperature", 0.7)
        )
        
        # Parse the response according to response_format
        parsed_response = self._parse_response(response, response_format)
        
        return parsed_response

# Register your custom LLM
from sofia.llms.factory import register_llm_provider

register_llm_provider("custom_llm", CustomLLM)

# Use your custom LLM
sofia = Sofia(
    name="custom_llm_agent",
    llm_provider="custom_llm",
    llm_config={
        "api_key": "your-custom-api-key",
        "model": "your-model-name",
        "temperature": 0.5
    },
    # Other configuration...
)
```

### Implementing Response Parsing

The most challenging part of creating a custom LLM provider is parsing responses. Here's a more detailed example:

```python
def _parse_response(self, response: str, response_format: Dict[str, Any]) -> Dict[str, Any]:
    """Parse the LLM response into the expected format.
    
    Args:
        response: Raw response from the LLM
        response_format: Expected response format
        
    Returns:
        Parsed response matching response_format
    """
    try:
        # Option 1: If your LLM supports JSON output directly
        if hasattr(self.client, "generate_structured") and response_format.get("type") == "json":
            return self.client.generate_structured(
                model=self.model,
                prompt=prompt,
                schema=response_format.get("schema")
            )
        
        # Option 2: Parse JSON from text response
        if response_format.get("type") == "json":
            import json
            import re
            
            # Extract JSON from response
            json_match = re.search(r'```json\s*(.*?)\s*```', response, re.DOTALL)
            if json_match:
                json_str = json_match.group(1)
            else:
                # Try to find JSON without code blocks
                json_match = re.search(r'({.*})', response, re.DOTALL)
                if json_match:
                    json_str = json_match.group(1)
                else:
                    json_str = response
            
            # Parse JSON
            parsed = json.loads(json_str)
            
            # Validate against schema
            self._validate_against_schema(parsed, response_format.get("schema", {}))
            
            return parsed
        
        # Option 3: Handle plain text response
        if response_format.get("type") == "text":
            return {"text": response}
        
        # Default fallback
        return {"raw_response": response}
    
    except Exception as e:
        logging.error(f"Failed to parse LLM response: {str(e)}")
        return {"error": str(e), "raw_response": response}
```

## Custom Session Stores

Implement custom session storage:

```python
from sofia.session import SessionStoreBase
from typing import Dict, Any, Optional

class CustomSessionStore(SessionStoreBase):
    def __init__(self, connection_string: str):
        """Initialize custom session store.
        
        Args:
            connection_string: Connection string for the storage backend
        """
        self.connection_string = connection_string
        self.db = self._connect()
    
    def _connect(self):
        # Connect to your storage backend
        # This is a placeholder
        return {"connected": True}
    
    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """Save session data.
        
        Args:
            session_id: Unique session identifier
            session_data: Session data to save
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Save session data to your storage backend
            # This is a placeholder
            print(f"Saving session {session_id}")
            return True
        except Exception as e:
            logging.error(f"Failed to save session: {str(e)}")
            return False
    
    def load_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Load session data.
        
        Args:
            session_id: Unique session identifier
            
        Returns:
            Session data if found, None otherwise
        """
        try:
            # Load session data from your storage backend
            # This is a placeholder
            print(f"Loading session {session_id}")
            return {
                "session_id": session_id,
                "current_step": "greeting",
                "history": [],
                "variables": {}
            }
        except Exception as e:
            logging.error(f"Failed to load session: {str(e)}")
            return None
    
    def delete_session(self, session_id: str) -> bool:
        """Delete a session.
        
        Args:
            session_id: Unique session identifier
            
        Returns:
            True if successful, False otherwise
        """
        try:
            # Delete session from your storage backend
            # This is a placeholder
            print(f"Deleting session {session_id}")
            return True
        except Exception as e:
            logging.error(f"Failed to delete session: {str(e)}")
            return False
    
    def list_sessions(self) -> List[str]:
        """List all session IDs.
        
        Returns:
            List of session IDs
        """
        try:
            # List sessions from your storage backend
            # This is a placeholder
            return ["session1", "session2", "session3"]
        except Exception as e:
            logging.error(f"Failed to list sessions: {str(e)}")
            return []

# Use your custom session store
sofia = Sofia(
    name="persistent_agent",
    session_store=CustomSessionStore("your-connection-string"),
    # Other configuration...
)
```

## Custom Step Types

Create specialized step types:

```python
from sofia.models.flow import Step, Route
from typing import List, Optional, Dict, Any

class FormStep(Step):
    """A step that collects form data from the user."""
    
    def __init__(
        self,
        step_id: str,
        description: str,
        fields: List[Dict[str, Any]],
        available_tools: Optional[List[str]] = None,
        routes: Optional[List[Route]] = None,
        validation_tool: Optional[str] = None
    ):
        """Initialize a form step.
        
        Args:
            step_id: Unique step identifier
            description: Step description
            fields: Form fields to collect
            available_tools: Available tools for this step
            routes: Routes to other steps
            validation_tool: Optional tool for validating form data
        """
        super().__init__(step_id, description, available_tools, routes)
        self.fields = fields
        self.validation_tool = validation_tool
        self.step_type = "form"
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert step to dictionary."""
        step_dict = super().to_dict()
        step_dict["fields"] = self.fields
        step_dict["validation_tool"] = self.validation_tool
        step_dict["step_type"] = self.step_type
        return step_dict

# Use your custom step type
form_step = FormStep(
    step_id="collect_info",
    description="Collect user information",
    fields=[
        {
            "name": "full_name",
            "type": "text",
            "required": True,
            "description": "User's full name"
        },
        {
            "name": "email",
            "type": "email",
            "required": True,
            "description": "User's email address"
        },
        {
            "name": "age",
            "type": "number",
            "required": False,
            "description": "User's age"
        }
    ],
    available_tools=["validate_email"],
    validation_tool="validate_form_data"
)

sofia = Sofia(
    name="form_agent",
    steps=[form_step],
    # Other configuration...
)
```

## Event Handlers

Add custom event handlers:

```python
from sofia import Sofia

# Create a SOFIA agent
sofia = Sofia(
    name="event_driven_agent",
    # Configuration...
)

# Register event handlers
@sofia.on("session_created")
def handle_session_created(event):
    session_id = event.get("session_id")
    print(f"New session created: {session_id}")
    # Initialize session-specific resources

@sofia.on("message_received")
def handle_message(event):
    session_id = event.get("session_id")
    message = event.get("message")
    print(f"Message received in session {session_id}: {message}")
    # Log message, update analytics, etc.

@sofia.on("tool_called")
def handle_tool_call(event):
    session_id = event.get("session_id")
    tool_name = event.get("tool_name")
    params = event.get("params")
    print(f"Tool {tool_name} called in session {session_id} with params {params}")
    # Log tool usage, monitor performance, etc.

@sofia.on("step_changed")
def handle_step_change(event):
    session_id = event.get("session_id")
    from_step = event.get("from_step")
    to_step = event.get("to_step")
    print(f"Session {session_id} moved from {from_step} to {to_step}")
    # Track flow progress, update metrics, etc.

@sofia.on("session_ended")
def handle_session_ended(event):
    session_id = event.get("session_id")
    print(f"Session ended: {session_id}")
    # Clean up resources, archive conversation, etc.
```

## Middleware

Create custom middleware for request processing:

```python
from sofia import Sofia
from sofia.middleware import Middleware
from typing import Dict, Any, Callable

class RateLimitMiddleware(Middleware):
    def __init__(self, requests_per_minute: int = 60):
        """Initialize rate limit middleware.
        
        Args:
            requests_per_minute: Maximum requests per minute per session
        """
        self.requests_per_minute = requests_per_minute
        self.session_timestamps = {}
    
    async def process_request(self, session_id: str, message: str, context: Dict[str, Any], next_handler: Callable):
        """Process an incoming request.
        
        Args:
            session_id: Session identifier
            message: User message
            context: Request context
            next_handler: Next handler in the chain
            
        Returns:
            Response from the next handler or rate limit error
        """
        import time
        
        # Get current time
        now = time.time()
        
        # Get timestamps for this session
        timestamps = self.session_timestamps.get(session_id, [])
        
        # Remove timestamps older than 1 minute
        timestamps = [ts for ts in timestamps if now - ts < 60]
        
        # Check rate limit
        if len(timestamps) >= self.requests_per_minute:
            return {
                "error": "Rate limit exceeded",
                "message": "Too many requests. Please try again later."
            }
        
        # Add current timestamp
        timestamps.append(now)
        self.session_timestamps[session_id] = timestamps
        
        # Proceed to next handler
        return await next_handler(session_id, message, context)

# Use the middleware
rate_limit_middleware = RateLimitMiddleware(requests_per_minute=30)

sofia = Sofia(
    name="rate_limited_agent",
    middleware=[rate_limit_middleware],
    # Other configuration...
)
```

## Plugin System

Create and use SOFIA plugins:

```python
from sofia import Sofia
from sofia.plugin import SofiaPlugin
from typing import Dict, Any

class AnalyticsPlugin(SofiaPlugin):
    def __init__(self, api_key: str, tracking_id: str):
        """Initialize analytics plugin.
        
        Args:
            api_key: API key for analytics service
            tracking_id: Tracking ID for analytics service
        """
        self.api_key = api_key
        self.tracking_id = tracking_id
        self.client = self._initialize_client()
    
    def _initialize_client(self):
        # Initialize analytics client
        # This is a placeholder
        return {"initialized": True}
    
    def on_initialize(self, sofia: Sofia):
        """Called when the plugin is initialized.
        
        Args:
            sofia: The SOFIA instance
        """
        # Register event handlers
        sofia.on("message_received", self.track_message)
        sofia.on("tool_called", self.track_tool_call)
        sofia.on("step_changed", self.track_step_change)
    
    def track_message(self, event: Dict[str, Any]):
        """Track a message event.
        
        Args:
            event: Event data
        """
        # Track message in analytics
        print(f"Tracking message: {event}")
    
    def track_tool_call(self, event: Dict[str, Any]):
        """Track a tool call event.
        
        Args:
            event: Event data
        """
        # Track tool call in analytics
        print(f"Tracking tool call: {event}")
    
    def track_step_change(self, event: Dict[str, Any]):
        """Track a step change event.
        
        Args:
            event: Event data
        """
        # Track step change in analytics
        print(f"Tracking step change: {event}")

# Create and register the plugin
analytics_plugin = AnalyticsPlugin(
    api_key="your-api-key",
    tracking_id="your-tracking-id"
)

sofia = Sofia(
    name="analytics_enabled_agent",
    plugins=[analytics_plugin],
    # Other configuration...
)
```

## Integrating External Services

### Database Integration

```python
import sqlite3
from contextlib import contextmanager
from typing import Any, Dict, List

class DatabaseIntegration:
    def __init__(self, db_path: str):
        """Initialize database integration.
        
        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = db_path
        self._initialize_db()
    
    def _initialize_db(self):
        """Initialize the database schema."""
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            # Create tables
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS products (
                    id INTEGER PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT,
                    price REAL NOT NULL,
                    category TEXT
                )
            ''')
            
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS customers (
                    id INTEGER PRIMARY KEY,
                    name TEXT NOT NULL,
                    email TEXT UNIQUE NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            conn.commit()
    
    @contextmanager
    def _get_connection(self):
        """Get a database connection."""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()
    
    def search_products(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """Search products by name or description.
        
        Args:
            query: Search query
            limit: Maximum number of results
            
        Returns:
            List of matching products
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT * FROM products
                WHERE name LIKE ? OR description LIKE ?
                LIMIT ?
            ''', (f'%{query}%', f'%{query}%', limit))
            
            results = [dict(row) for row in cursor.fetchall()]
            return results
    
    def get_customer(self, email: str) -> Dict[str, Any]:
        """Get customer by email.
        
        Args:
            email: Customer email
            
        Returns:
            Customer data if found, empty dict otherwise
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                SELECT * FROM customers
                WHERE email = ?
            ''', (email,))
            
            row = cursor.fetchone()
            if row:
                return dict(row)
            return {}
    
    def add_customer(self, name: str, email: str) -> Dict[str, Any]:
        """Add a new customer.
        
        Args:
            name: Customer name
            email: Customer email
            
        Returns:
            New customer data
        """
        with self._get_connection() as conn:
            cursor = conn.cursor()
            
            cursor.execute('''
                INSERT INTO customers (name, email)
                VALUES (?, ?)
            ''', (name, email))
            
            conn.commit()
            
            return {
                "id": cursor.lastrowid,
                "name": name,
                "email": email
            }

# Initialize database integration
db = DatabaseIntegration("sofia_data.db")

# Create tools using the database integration
def search_products(query: str, limit: int = 10) -> list:
    """Search products by name or description.
    
    Args:
        query: Search query
        limit: Maximum number of results
        
    Returns:
        List of matching products
    """
    return db.search_products(query, limit)

def get_customer_by_email(email: str) -> dict:
    """Get customer information by email.
    
    Args:
        email: Customer email address
        
    Returns:
        Customer information or empty dict if not found
    """
    return db.get_customer(email)

def add_new_customer(name: str, email: str) -> dict:
    """Add a new customer to the database.
    
    Args:
        name: Customer name
        email: Customer email address
        
    Returns:
        New customer information
    """
    return db.add_customer(name, email)

# Register tools with SOFIA
sofia = Sofia(
    name="database_integrated_agent",
    tools=[search_products, get_customer_by_email, add_new_customer],
    # Other configuration...
)
```

### API Integration

```python
import requests
from typing import Dict, Any, List, Optional

class APIIntegration:
    def __init__(self, base_url: str, api_key: str):
        """Initialize API integration.
        
        Args:
            base_url: Base URL for the API
            api_key: API key for authentication
        """
        self.base_url = base_url
        self.api_key = api_key
        self.session = requests.Session()
        self.session.headers.update({
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        })
    
    def _handle_response(self, response: requests.Response) -> Dict[str, Any]:
        """Handle API response.
        
        Args:
            response: Response object
            
        Returns:
            Parsed response data
            
        Raises:
            Exception: If the request failed
        """
        try:
            response.raise_for_status()
            return response.json()
        except requests.exceptions.HTTPError as e:
            error_message = f"HTTP error: {e}"
            try:
                error_data = response.json()
                if "error" in error_data:
                    error_message = f"API error: {error_data['error']}"
            except:
                pass
            raise Exception(error_message)
        except Exception as e:
            raise Exception(f"Request failed: {str(e)}")
    
    def get_products(self, category: Optional[str] = None, limit: int = 10) -> List[Dict[str, Any]]:
        """Get products from the API.
        
        Args:
            category: Optional category filter
            limit: Maximum number of products to return
            
        Returns:
            List of products
        """
        params = {"limit": limit}
        if category:
            params["category"] = category
        
        response = self.session.get(f"{self.base_url}/products", params=params)
        data = self._handle_response(response)
        
        return data.get("products", [])
    
    def get_product(self, product_id: str) -> Dict[str, Any]:
        """Get a product by ID.
        
        Args:
            product_id: Product ID
            
        Returns:
            Product data
        """
        response = self.session.get(f"{self.base_url}/products/{product_id}")
        return self._handle_response(response)
    
    def create_order(self, customer_id: str, products: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create a new order.
        
        Args:
            customer_id: Customer ID
            products: List of products to order
            
        Returns:
            Order data
        """
        data = {
            "customer_id": customer_id,
            "products": products
        }
        
        response = self.session.post(f"{self.base_url}/orders", json=data)
        return self._handle_response(response)

# Initialize API integration
api = APIIntegration(
    base_url="https://api.example.com/v1",
    api_key="your-api-key"
)

# Create tools using the API integration
def get_products(category: Optional[str] = None, limit: int = 10) -> list:
    """Get products from the catalog.
    
    Args:
        category: Optional category filter
        limit: Maximum number of products to return
        
    Returns:
        List of products
    """
    return api.get_products(category, limit)

def get_product_details(product_id: str) -> dict:
    """Get detailed information about a product.
    
    Args:
        product_id: Product ID
        
    Returns:
        Product details
    """
    return api.get_product(product_id)

def place_order(customer_id: str, products: list) -> dict:
    """Place a new order.
    
    Args:
        customer_id: Customer ID
        products: List of products to order, each with product_id and quantity
        
    Returns:
        Order details
    """
    return api.create_order(customer_id, products)

# Register tools with SOFIA
sofia = Sofia(
    name="ecommerce_agent",
    tools=[get_products, get_product_details, place_order],
    # Other configuration...
)
```

## Extension Best Practices

1. **Follow the Single Responsibility Principle**: Each extension should do one thing well
2. **Document Thoroughly**: Provide clear documentation for your extensions
3. **Handle Errors Gracefully**: Implement proper error handling and fallbacks
4. **Test Extensions Independently**: Ensure extensions work correctly before integration
5. **Use Type Annotations**: Help SOFIA understand your extension interfaces
6. **Maintain Backward Compatibility**: Avoid breaking changes when updating extensions
7. **Monitor Performance**: Track and optimize extension performance

<Callout type="info">
  When creating extensions, structure your code to be easily testable and maintainable. Consider creating a separate package for complex extensions.
</Callout>

## Next Steps

- Explore the [API Reference](/api/core-api) for detailed information on SOFIA's APIs
- Visit [Tool Development](/api/tool-development) for in-depth tool development guidance
- Learn about [Deployment](/guides/deployment) to deploy your extended SOFIA agents
