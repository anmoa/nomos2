---
title: "Tools"
description: "Learn how to integrate and manage tools in your NOMOS agents"
---

# Tools

Tools are the hands and eyes of your NOMOS agent—they enable interaction with external systems, data processing, and action execution. NOMOS provides a flexible and secure tool integration system that gives agents capabilities while maintaining control and auditability.

## What Are Tools?

<Info>
**Tools = Agent Capabilities**

Tools are functions that your agent can call to interact with the world—from simple calculations to complex API integrations, database queries, or external service calls.
</Info>

<CardGroup cols={2}>
  <Card title="Function-Based" icon="code" iconType="solid">
    Convert any Python function into an agent tool with automatic parameter validation
  </Card>
  <Card title="Contextual Access" icon="key" iconType="solid">
    Tools are only available when needed, improving security and reducing confusion
  </Card>
  <Card title="Type Safety" icon="shield-check" iconType="solid">
    Automatic parameter validation and type checking prevent runtime errors
  </Card>
  <Card title="Framework Integration" icon="puzzle-piece" iconType="solid">
    Compatible with existing tools from LangChain, CrewAI, and other frameworks
  </Card>
</CardGroup>

## Tool Definition

### Basic Python Function

The simplest way to create a tool is with a regular Python function:

```python
# barista_tools.py
def get_available_coffee_options() -> str:
    """
    Get available coffee options, sizes, and prices.

    Returns:
        str: Formatted list of available coffee options with prices
    """
    coffee_options = [
        {
            "type": "Espresso",
            "sizes": ["Small", "Medium", "Large"],
            "prices": [2.5, 3.0, 3.5],
        },
        {
            "type": "Latte",
            "sizes": ["Small", "Medium", "Large"],
            "prices": [3.0, 3.5, 4.0],
        }
    ]

    result = "Available Coffee Options:\n"
    for option in coffee_options:
        result += f"{option['type']}: "
        for size, price in zip(option['sizes'], option['prices']):
            result += f"{size} (${price}) "
        result += "\n"

    return result

def add_to_cart(coffee_type: str, size: str, price: float) -> str:
    """
    Add a coffee item to the customer's cart.

    Args:
        coffee_type: Type of coffee (e.g., Espresso, Latte, Cappuccino)
        size: Size of the coffee (Small, Medium, Large)
        price: Price of the coffee item

    Returns:
        str: Confirmation message with updated cart total
    """
    # Implementation logic here
    item = {
        "coffee_type": coffee_type,
        "size": size,
        "price": price,
        "id": generate_item_id()
    }
    coffee_cart.append(item)

    current_total = sum(item["price"] for item in coffee_cart)
    return f"Added {size} {coffee_type} to cart. Current total: ${current_total:.2f}"
```

## Tool Configuration

### In YAML Configuration

Tools are referenced in your agent configuration:

```yaml
name: barista
persona: "You are a helpful barista assistant..."
start_step_id: start

steps:
  - step_id: start
    description: "Greet customer and show menu options"
    available_tools:
      - get_available_coffee_options
    routes:
      - target: take_coffee_order
        condition: Customer is ready to order

  - step_id: take_coffee_order
    description: "Take and manage coffee orders"
    available_tools:
      - get_available_coffee_options
      - add_to_cart
      - remove_item
      - clear_cart
    routes:
      - target: finalize_order
        condition: Customer wants to finalize order

# Tool configuration
tools:
  tool_files:
    - barista_tools.py
  tool_defs:
    add_to_cart:
      args:
        - key: coffee_type
          desc: "Type of coffee (e.g., Espresso, Latte, Cappuccino)"
        - key: size
          desc: "Size of the coffee (Small, Medium, Large)"
        - key: price
          desc: "Price of the coffee"
```

### Enhanced Tool Definitions

You can provide additional context for tools:

```yaml
tools:
  tool_files:
    - financial_tools.py
    - external_apis.py

  tool_defs:
    calculate_budget:
      desc: "Calculate recommended budget allocation based on income"
      args:
        - key: monthly_income
          desc: "User's monthly income in dollars"
          type: "float"
        - key: has_dependents
          desc: "Whether the user has dependents"
          type: "bool"

    get_stock_price:
      desc: "Get current stock price from external API"
      args:
        - key: symbol
          desc: "Stock symbol (e.g., AAPL, GOOGL)"
          type: "str"
        - key: exchange
          desc: "Stock exchange (optional)"
          type: "str"
```

## Tool Types

### 1. **Information Retrieval Tools**

<Card title="Data Access" icon="database">
Tools that fetch information from databases, APIs, or knowledge bases
</Card>

```python
def search_knowledge_base(query: str) -> str:
    """
    Search the company knowledge base for relevant information.

    Args:
        query: Search query string

    Returns:
        str: Relevant information from knowledge base
    """
    # Implementation using vector search, database query, etc.
    results = vector_search(query, top_k=5)
    return format_search_results(results)

def get_weather(location: str) -> str:
    """
    Get current weather information for a location.

    Args:
        location: City name or coordinates

    Returns:
        str: Weather information
    """
    response = requests.get(f"https://api.weather.com/v1/current?location={location}")
    return format_weather_data(response.json())
```

### 2. **Action Tools**

<Card title="System Actions" icon="play">
Tools that perform actions or modify system state
</Card>

```python
def send_email(recipient: str, subject: str, body: str) -> str:
    """
    Send an email to the specified recipient.

    Args:
        recipient: Email address of recipient
        subject: Email subject line
        body: Email body content

    Returns:
        str: Confirmation of email sent
    """
    # Email sending logic
    email_service.send(recipient, subject, body)
    return f"Email sent successfully to {recipient}"

def create_calendar_event(title: str, start_time: str, duration: int) -> str:
    """
    Create a new calendar event.

    Args:
        title: Event title
        start_time: Start time in ISO format
        duration: Duration in minutes

    Returns:
        str: Confirmation with event details
    """
    # Calendar API integration
    event = calendar_api.create_event(title, start_time, duration)
    return f"Created event '{title}' at {start_time}"
```

### 3. **Calculation Tools**

<Card title="Processing" icon="calculator">
Tools that perform calculations or data processing
</Card>

```python
def calculate_loan_payment(principal: float, rate: float, years: int) -> str:
    """
    Calculate monthly loan payment.

    Args:
        principal: Loan amount in dollars
        rate: Annual interest rate as decimal (e.g., 0.05 for 5%)
        years: Loan term in years

    Returns:
        str: Monthly payment amount and total interest
    """
    monthly_rate = rate / 12
    num_payments = years * 12

    monthly_payment = principal * (monthly_rate * (1 + monthly_rate)**num_payments) / \
                     ((1 + monthly_rate)**num_payments - 1)

    total_paid = monthly_payment * num_payments
    total_interest = total_paid - principal

    return f"Monthly payment: ${monthly_payment:.2f}, Total interest: ${total_interest:.2f}"
```

## Advanced Tool Features

### Async Tools

NOMOS supports asynchronous tools for I/O operations:

```python
import asyncio
import aiohttp

async def fetch_stock_data(symbol: str) -> str:
    """
    Asynchronously fetch stock data.

    Args:
        symbol: Stock symbol to fetch

    Returns:
        str: Stock price and change information
    """
    async with aiohttp.ClientSession() as session:
        async with session.get(f"https://api.stocks.com/{symbol}") as response:
            data = await response.json()
            return f"{symbol}: ${data['price']} ({data['change']:+.2f})"
```

### Error Handling

Tools should handle errors gracefully:

```python
def get_user_profile(user_id: str) -> str:
    """
    Get user profile information.

    Args:
        user_id: Unique user identifier

    Returns:
        str: User profile information or error message
    """
    try:
        user = database.get_user(user_id)
        if not user:
            return f"User {user_id} not found"

        return f"User: {user.name}, Email: {user.email}, Status: {user.status}"

    except DatabaseError as e:
        return f"Error accessing user data: {str(e)}"
    except Exception as e:
        return f"Unexpected error: {str(e)}"
```

### Tool Validation

NOMOS automatically validates tool parameters:

```python
from typing import Literal

def set_thermostat(temperature: float, unit: Literal["F", "C"] = "F") -> str:
    """
    Set thermostat temperature.

    Args:
        temperature: Desired temperature
        unit: Temperature unit (F or C)

    Returns:
        str: Confirmation of temperature setting
    """
    if unit == "C" and (temperature < 10 or temperature > 35):
        return "Temperature out of reasonable range for Celsius"
    elif unit == "F" and (temperature < 50 or temperature > 95):
        return "Temperature out of reasonable range for Fahrenheit"

    # Set temperature logic
    return f"Thermostat set to {temperature}°{unit}"
```

## External Tool Integration

### LangChain Tools

```python
from langchain_community.tools import DuckDuckGoSearchRun

# Use LangChain tools directly
search = DuckDuckGoSearchRun()

def web_search(query: str) -> str:
    """
    Search the web using DuckDuckGo.

    Args:
        query: Search query

    Returns:
        str: Search results
    """
    return search.run(query)
```

### Custom API Integrations

```python
import requests
from typing import Optional

def slack_send_message(channel: str, message: str, thread_ts: Optional[str] = None) -> str:
    """
    Send message to Slack channel.

    Args:
        channel: Slack channel name or ID
        message: Message to send
        thread_ts: Thread timestamp for replies (optional)

    Returns:
        str: Confirmation of message sent
    """
    payload = {
        "channel": channel,
        "text": message
    }

    if thread_ts:
        payload["thread_ts"] = thread_ts

    response = requests.post(
        "https://slack.com/api/chat.postMessage",
        headers={"Authorization": f"Bearer {SLACK_TOKEN}"},
        json=payload
    )

    if response.json()["ok"]:
        return f"Message sent to {channel}"
    else:
        return f"Failed to send message: {response.json()['error']}"
```

## Tool Security and Best Practices

### 1. **Principle of Least Privilege**

<Card title="Minimal Access" icon="shield">
Only provide tools when needed for specific steps
</Card>

```yaml
# Good: Minimal tool access per step
steps:
  - step_id: greeting
    available_tools: []  # No tools needed for greeting

  - step_id: lookup_order
    available_tools: [search_orders]  # Only order search

  - step_id: process_refund
    available_tools: [search_orders, process_refund]  # Add refund capability
```

### 2. **Input Validation**

<Card title="Parameter Safety" icon="check-shield">
Validate all tool inputs to prevent security issues
</Card>

```python
def execute_database_query(table: str, conditions: str) -> str:
    """
    Execute a safe database query.

    Args:
        table: Table name (validated against allowed tables)
        conditions: WHERE conditions (sanitized)

    Returns:
        str: Query results
    """
    # Validate table name against whitelist
    allowed_tables = ["orders", "customers", "products"]
    if table not in allowed_tables:
        return f"Table '{table}' not allowed"

    # Sanitize conditions to prevent SQL injection
    sanitized_conditions = sanitize_sql(conditions)

    # Execute safe query
    return execute_safe_query(table, sanitized_conditions)
```

### 3. **Rate Limiting**

<Card title="Resource Protection" icon="clock">
Implement rate limiting for expensive operations
</Card>

```python
from functools import lru_cache
import time

@lru_cache(maxsize=100)
def expensive_api_call(query: str) -> str:
    """
    Cached API call with rate limiting.

    Args:
        query: API query parameter

    Returns:
        str: API response
    """
    # Rate limiting logic
    time.sleep(0.1)  # Prevent API abuse

    response = external_api.query(query)
    return process_response(response)
```

## Tool Testing

Tools can be tested independently:

```python
# test_tools.py
import pytest
from barista_tools import add_to_cart, get_total_price

def test_add_to_cart():
    """Test adding items to cart."""
    # Clear cart first
    coffee_cart.clear()

    result = add_to_cart("Latte", "Medium", 3.5)

    assert "Added Medium Latte to cart" in result
    assert "3.50" in result
    assert len(coffee_cart) == 1

def test_invalid_coffee_type():
    """Test handling of invalid coffee types."""
    result = add_to_cart("Unicorn Frappuccino", "Large", 5.0)

    assert "not available" in result.lower()
```

## Tool Documentation

Good tool documentation helps the LLM use tools effectively:

```python
def complex_calculation(
    base_amount: float,
    tax_rate: float,
    discount_percent: float = 0.0,
    shipping_cost: float = 0.0
) -> str:
    """
    Calculate final price including tax, discount, and shipping.

    This tool calculates the total cost for a purchase including all fees
    and discounts. Use this when customers ask about final pricing.

    Args:
        base_amount: Base price before tax and fees (required)
        tax_rate: Tax rate as decimal (e.g., 0.08 for 8% tax) (required)
        discount_percent: Discount percentage (e.g., 10 for 10% off) (optional)
        shipping_cost: Additional shipping cost (optional)

    Returns:
        str: Detailed breakdown of final price calculation

    Example:
        >>> complex_calculation(100.0, 0.08, 10.0, 5.95)
        "Base: $100.00, Discount: -$10.00, Tax: $7.20, Shipping: $5.95, Total: $103.15"
    """
    discounted_amount = base_amount * (1 - discount_percent / 100)
    tax_amount = discounted_amount * tax_rate
    total = discounted_amount + tax_amount + shipping_cost

    return (f"Base: ${base_amount:.2f}, Discount: -${base_amount - discounted_amount:.2f}, "
            f"Tax: ${tax_amount:.2f}, Shipping: ${shipping_cost:.2f}, Total: ${total:.2f}")
```

<Tip>
**Clear Documentation = Better Tool Usage**

The more clearly you document your tools, the more effectively your agent will use them. Include examples and edge cases in your docstrings.
</Tip>

## Real-World Tool Examples

Here are some practical tools from the NOMOS examples:

<CodeGroup>
```python Financial Tools
def calculate_budget(monthly_income: float) -> str:
    """Calculate recommended budget allocation."""
    allocations = {
        "Housing": monthly_income * 0.30,
        "Food": monthly_income * 0.15,
        "Transportation": monthly_income * 0.15,
        "Savings": monthly_income * 0.20,
        "Entertainment": monthly_income * 0.10,
        "Other": monthly_income * 0.10
    }

    result = "Recommended Budget Allocation:\n"
    for category, amount in allocations.items():
        result += f"{category}: ${amount:.2f}\n"

    return result
```

```python Search Tools
def search_google(query: str) -> str:
    """Search Google for information."""
    # Integration with search API
    results = google_search_api.search(query, num_results=5)

    formatted_results = "Search Results:\n"
    for i, result in enumerate(results, 1):
        formatted_results += f"{i}. {result['title']}\n"
        formatted_results += f"   {result['snippet']}\n\n"

    return formatted_results
```

```python E-commerce Tools
def get_order_status(order_id: str) -> str:
    """Look up order status by ID."""
    try:
        order = order_database.get_order(order_id)
        return f"Order {order_id}: Status {order.status}, Tracking: {order.tracking_number}"
    except OrderNotFound:
        return f"Order {order_id} not found. Please check the order number."
```
</CodeGroup>

Tools are the bridge between your agent's intelligence and real-world capabilities. By designing them thoughtfully with proper security, validation, and documentation, you can create powerful agents that are both capable and safe.
